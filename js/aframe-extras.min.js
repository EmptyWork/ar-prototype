!function e(t, n, i) { function r(o, s) { if (!n[o]) { if (!t[o]) { var c = "function" == typeof require && require; if (!s && c) return c(o, !0); if (a) return a(o, !0); var l = new Error("Cannot find module '" + o + "'"); throw l.code = "MODULE_NOT_FOUND", l } var h = n[o] = { exports: {} }; t[o][0].call(h.exports, function (e) { var n = t[o][1][e]; return r(n || e) }, h, h.exports, e, t, n, i) } return n[o].exports } for (var a = "function" == typeof require && require, o = 0; o < i.length; o++)r(i[o]); return r }({ 1: [function (e, t, n) { "use strict"; e("./") }, { "./": 2 }], 2: [function (e, t, n) { "use strict"; e("./src/controls"), e("./src/loaders"), e("./src/misc"), e("./src/pathfinding"), e("./src/primitives") }, { "./src/controls": 13, "./src/loaders": 22, "./src/misc": 27, "./src/pathfinding": 30, "./src/primitives": 37 }], 3: [function (e, t, n) { "use strict"; t.exports = THREE.ColladaLoader = function (e) { this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager }, THREE.ColladaLoader.prototype = { constructor: THREE.ColladaLoader, crossOrigin: "anonymous", load: function (e, t, n, i) { var r = this, a = void 0 === r.path ? THREE.LoaderUtils.extractUrlBase(e) : r.path, o = new THREE.FileLoader(r.manager); o.setPath(r.path), o.load(e, function (e) { t(r.parse(e, a)) }, n, i) }, setPath: function (e) { return this.path = e, this }, setResourcePath: function (e) { return this.resourcePath = e, this }, options: { set convertUpAxis(e) { console.warn("THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.") } }, setCrossOrigin: function (e) { return this.crossOrigin = e, this }, parse: function (e, t) { function n(e, t) { for (var n = [], i = e.childNodes, r = 0, a = i.length; r < a; r++) { var o = i[r]; o.nodeName === t && n.push(o) } return n } function i(e) { if (0 === e.length) return []; for (var t = e.trim().split(/\s+/), n = new Array(t.length), i = 0, r = t.length; i < r; i++)n[i] = t[i]; return n } function r(e) { if (0 === e.length) return []; for (var t = e.trim().split(/\s+/), n = new Array(t.length), i = 0, r = t.length; i < r; i++)n[i] = parseFloat(t[i]); return n } function a(e) { if (0 === e.length) return []; for (var t = e.trim().split(/\s+/), n = new Array(t.length), i = 0, r = t.length; i < r; i++)n[i] = parseInt(t[i]); return n } function o(e) { return e.substring(1) } function s() { return "three_default_" + se++ } function c(e) { return 0 === Object.keys(e).length } function l(e, t, i, r) { var a = n(e, t)[0]; if (void 0 !== a) for (var o = n(a, i), s = 0; s < o.length; s++)r(o[s]) } function h(e, t) { for (var n in e) { e[n].build = t(e[n]) } } function u(e, t) { return void 0 !== e.build ? e.build : (e.build = t(e), e.build) } function d(e) { var t = [], n = e.channels, i = e.samplers, r = e.sources; for (var a in n) if (n.hasOwnProperty(a)) { var o = n[a], s = i[o.sampler], c = s.inputs.INPUT, l = s.inputs.OUTPUT; !function (e, t) { for (var n = e.keyframes, i = e.name, r = [], a = [], o = [], s = [], c = 0, l = n.length; c < l; c++) { var h = n[c], u = h.time, d = h.value; J.fromArray(d).transpose(), J.decompose(Y, Z, K), r.push(u), a.push(Y.x, Y.y, Y.z), o.push(Z.x, Z.y, Z.z, Z.w), s.push(K.x, K.y, K.z) } a.length > 0 && t.push(new THREE.VectorKeyframeTrack(i + ".position", r, a)); o.length > 0 && t.push(new THREE.QuaternionKeyframeTrack(i + ".quaternion", r, o)); s.length > 0 && t.push(new THREE.VectorKeyframeTrack(i + ".scale", r, s)) }(function (e, t, n) { var i, r, a, o, s, c, l = ce.nodes[e.id], h = j(l.id), u = l.transforms[e.sid], d = l.matrix.clone().transpose(), p = {}; switch (u) { case "matrix": for (a = 0, o = t.array.length; a < o; a++)if (i = t.array[a], r = a * n.stride, void 0 === p[i] && (p[i] = {}), !0 === e.arraySyntax) { var f = n.array[r], m = e.indices[0] + 4 * e.indices[1]; p[i][m] = f } else for (s = 0, c = n.stride; s < c; s++)p[i][s] = n.array[r + s]; break; case "translate": case "rotate": case "scale": console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', u) }var g = function (e, t) { var n = []; for (var i in e) n.push({ time: parseFloat(i), value: e[i] }); n.sort(function (e, t) { return e.time - t.time }); for (var r = 0; r < 16; r++)!function (e, t, n) { var i, r, a, o = !0; for (r = 0, a = e.length; r < a; r++)void 0 === (i = e[r]).value[t] ? i.value[t] = null : o = !1; if (!0 === o) for (r = 0, a = e.length; r < a; r++)(i = e[r]).value[t] = n; else !function (e, t) { for (var n, i, r = 0, a = e.length; r < a; r++) { var o = e[r]; if (null === o.value[t]) { if (n = function (e, t, n) { for (; t >= 0;) { var i = e[t]; if (null !== i.value[n]) return i; t-- } return null }(e, r, t), i = function (e, t, n) { for (; t < e.length;) { var i = e[t]; if (null !== i.value[n]) return i; t++ } return null }(e, r, t), null === n) { o.value[t] = i.value[t]; continue } if (null === i) { o.value[t] = n.value[t]; continue } !function (e, t, n, i) { if (n.time - t.time == 0) return void (e.value[i] = t.value[i]); e.value[i] = (e.time - t.time) * (n.value[i] - t.value[i]) / (n.time - t.time) + t.value[i] }(o, n, i, t) } } }(e, t) }(n, r, t.elements[r]); return n }(p, d); return { name: h.uuid, keyframes: g } }(o, r[c], r[l]), t) } return t } function p(e) { return u(ce.animations[e], d) } function f(e) { for (var t = [], n = e.name, i = e.end - e.start || -1, r = e.animations, a = 0, o = r.length; a < o; a++)for (var s = p(r[a]), c = 0, l = s.length; c < l; c++)t.push(s[c]); return new THREE.AnimationClip(n, i, t) } function m(e) { return u(ce.clips[e], f) } function g(e) { var t = { id: e.id }, n = ce.geometries[t.id]; return void 0 !== e.skin && (t.skin = function (e) { function t(e, t) { return t.weight - e.weight } var n, i, r, a = { joints: [], indices: { array: [], stride: 4 }, weights: { array: [], stride: 4 } }, o = e.sources, s = e.vertexWeights, c = s.vcount, l = s.v, h = s.inputs.JOINT.offset, u = s.inputs.WEIGHT.offset, d = e.sources[e.joints.inputs.JOINT], p = e.sources[e.joints.inputs.INV_BIND_MATRIX], f = o[s.inputs.WEIGHT.id].array, m = 0; for (n = 0, r = c.length; n < r; n++) { var g = c[n], v = []; for (i = 0; i < g; i++) { var y = l[m + h], x = l[m + u], _ = f[x]; v.push({ index: y, weight: _ }), m += 2 } for (v.sort(t), i = 0; i < 4; i++) { var b = v[i]; void 0 !== b ? (a.indices.array.push(b.index), a.weights.array.push(b.weight)) : (a.indices.array.push(0), a.weights.array.push(0)) } } e.bindShapeMatrix ? a.bindMatrix = (new THREE.Matrix4).fromArray(e.bindShapeMatrix).transpose() : a.bindMatrix = (new THREE.Matrix4).identity(); for (n = 0, r = d.array.length; n < r; n++) { var E = d.array[n], w = (new THREE.Matrix4).fromArray(p.array, n * p.stride).transpose(); a.joints.push({ name: E, boneInverse: w }) } return a }(e.skin), n.sources.skinIndices = t.skin.indices, n.sources.skinWeights = t.skin.weights), t } function v(e) { return u(ce.controllers[e], g) } function y(e) { return void 0 !== e.build ? e.build : e.init_from } function x(e) { var t = ce.images[e]; return void 0 !== t ? u(t, y) : (console.warn("THREE.ColladaLoader: Couldn't find image with ID:", e), null) } function _(e) { for (var t = {}, n = 0, i = e.childNodes.length; n < i; n++) { var a = e.childNodes[n]; if (1 === a.nodeType) switch (a.nodeName) { case "color": t[a.nodeName] = r(a.textContent); break; case "float": t[a.nodeName] = parseFloat(a.textContent); break; case "texture": t[a.nodeName] = { id: a.getAttribute("texture"), extra: function (e) { for (var t = { technique: {} }, n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "extra": !function (e, t) { for (var n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "technique": !function (e, t) { for (var n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "repeatU": case "repeatV": case "offsetU": case "offsetV": t.technique[r.nodeName] = parseFloat(r.textContent); break; case "wrapU": case "wrapV": "TRUE" === r.textContent.toUpperCase() ? t.technique[r.nodeName] = 1 : "FALSE" === r.textContent.toUpperCase() ? t.technique[r.nodeName] = 0 : t.technique[r.nodeName] = parseInt(r.textContent) } } }(r, t) } } }(r, t) } } return t }(a) } } } return t } function b(e) { return e } function E(e) { function t(e) { var t = i.profile.samplers[e.id], n = null; if (void 0 !== t) { n = x(i.profile.surfaces[t.source].init_from) } else console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530)."), n = x(e.id); if (null !== n) { var r = function (e) { var t, n = e.slice(2 + (e.lastIndexOf(".") - 1 >>> 0)); switch (n = n.toLowerCase()) { case "tga": t = re; break; default: t = ie }return t }(n); if (void 0 !== r) { var a = r.load(n), o = e.extra; if (void 0 !== o && void 0 !== o.technique && !1 === c(o.technique)) { var s = o.technique; a.wrapS = s.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping, a.wrapT = s.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping, a.offset.set(s.offsetU || 0, s.offsetV || 0), a.repeat.set(s.repeatU || 1, s.repeatV || 1) } else a.wrapS = THREE.RepeatWrapping, a.wrapT = THREE.RepeatWrapping; return a } return console.warn("THREE.ColladaLoader: Loader for texture %s not found.", n), null } return console.warn("THREE.ColladaLoader: Couldn't create texture with ID:", e.id), null } var n, i = function (e) { return u(ce.effects[e], b) }(e.url), r = i.profile.technique, a = i.profile.extra; switch (r.type) { case "phong": case "blinn": n = new THREE.MeshPhongMaterial; break; case "lambert": n = new THREE.MeshLambertMaterial; break; default: n = new THREE.MeshBasicMaterial }n.name = e.name; var o = r.parameters; for (var s in o) { var l = o[s]; switch (s) { case "diffuse": l.color && n.color.fromArray(l.color), l.texture && (n.map = t(l.texture)); break; case "specular": l.color && n.specular && n.specular.fromArray(l.color), l.texture && (n.specularMap = t(l.texture)); break; case "bump": l.texture && (n.normalMap = t(l.texture)); break; case "ambient": l.texture && (n.lightMap = t(l.texture)); break; case "shininess": l.float && n.shininess && (n.shininess = l.float); break; case "emission": l.color && n.emissive && n.emissive.fromArray(l.color), l.texture && (n.emissiveMap = t(l.texture)) } } var h = o.transparent, d = o.transparency; if (void 0 === d && h && (d = { float: 1 }), void 0 === h && d && (h = { opaque: "A_ONE", data: { color: [1, 1, 1, 1] } }), h && d) if (h.data.texture) n.transparent = !0; else { var p = h.data.color; switch (h.opaque) { case "A_ONE": n.opacity = p[3] * d.float; break; case "RGB_ZERO": n.opacity = 1 - p[0] * d.float; break; case "A_ZERO": n.opacity = 1 - p[3] * d.float; break; case "RGB_ONE": n.opacity = p[0] * d.float; break; default: console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', h.opaque) }n.opacity < 1 && (n.transparent = !0) } return void 0 !== a && void 0 !== a.technique && 1 === a.technique.double_sided && (n.side = THREE.DoubleSide), n } function w(e) { return u(ce.materials[e], E) } function M(e) { var t; switch (e.optics.technique) { case "perspective": t = new THREE.PerspectiveCamera(e.optics.parameters.yfov, e.optics.parameters.aspect_ratio, e.optics.parameters.znear, e.optics.parameters.zfar); break; case "orthographic": var n = e.optics.parameters.ymag, i = e.optics.parameters.xmag, r = e.optics.parameters.aspect_ratio; i = void 0 === i ? n * r : i, n = void 0 === n ? i / r : n, i *= .5, n *= .5, t = new THREE.OrthographicCamera(-i, i, n, -n, e.optics.parameters.znear, e.optics.parameters.zfar); break; default: t = new THREE.PerspectiveCamera }return t.name = e.name, t } function T(e) { var t = ce.cameras[e]; return void 0 !== t ? u(t, M) : (console.warn("THREE.ColladaLoader: Couldn't find camera with ID:", e), null) } function S(e) { var t; switch (e.technique) { case "directional": t = new THREE.DirectionalLight; break; case "point": t = new THREE.PointLight; break; case "spot": t = new THREE.SpotLight; break; case "ambient": t = new THREE.AmbientLight }return e.parameters.color && t.color.copy(e.parameters.color), e.parameters.distance && (t.distance = e.parameters.distance), t } function A(e) { var t = ce.lights[e]; return void 0 !== t ? u(t, S) : (console.warn("THREE.ColladaLoader: Couldn't find light with ID:", e), null) } function R(e) { for (var t = { array: [], stride: 3 }, a = 0; a < e.childNodes.length; a++) { var o = e.childNodes[a]; if (1 === o.nodeType) switch (o.nodeName) { case "float_array": t.array = r(o.textContent); break; case "Name_array": t.array = i(o.textContent); break; case "technique_common": var s = n(o, "accessor")[0]; void 0 !== s && (t.stride = parseInt(s.getAttribute("stride"))) } } return t } function L(e) { for (var t = 0, n = 0, i = e.length; n < i; n++) { !0 === e[n].hasUV && t++ } t > 0 && t < e.length && (e.uvsNeedsFix = !0) } function C(e) { var t = {}, n = e.sources, i = e.vertices, r = e.primitives; if (0 === r.length) return {}; var a = function (e) { for (var t = {}, n = 0; n < e.length; n++) { var i = e[n]; void 0 === t[i.type] && (t[i.type] = []), t[i.type].push(i) } return t }(r); for (var o in a) { var s = a[o]; L(s), t[o] = function (e, t, n) { for (var i = {}, r = { array: [], stride: 0 }, a = { array: [], stride: 0 }, o = { array: [], stride: 0 }, s = { array: [], stride: 0 }, c = { array: [], stride: 0 }, l = { array: [], stride: 4 }, h = { array: [], stride: 4 }, u = new THREE.BufferGeometry, d = [], p = 0, f = 0; f < e.length; f++) { var m = e[f], g = m.inputs, v = 0; switch (m.type) { case "lines": case "linestrips": v = 2 * m.count; break; case "triangles": v = 3 * m.count; break; case "polylist": for (var y = 0; y < m.count; y++) { var x = m.vcount[y]; switch (x) { case 3: v += 3; break; case 4: v += 6; break; default: v += 3 * (x - 2) } } break; default: console.warn("THREE.ColladaLoader: Unknow primitive type:", m.type) }u.addGroup(p, v, f), p += v, m.material && d.push(m.material); for (var _ in g) { var b = g[_]; switch (_) { case "VERTEX": for (var E in n) { var w = n[E]; switch (E) { case "POSITION": var M = r.array.length; if (P(m, t[w], b.offset, r.array), r.stride = t[w].stride, t.skinWeights && t.skinIndices && (P(m, t.skinIndices, b.offset, l.array), P(m, t.skinWeights, b.offset, h.array)), !1 === m.hasUV && !0 === e.uvsNeedsFix) for (var v = (r.array.length - M) / r.stride, T = 0; T < v; T++)o.array.push(0, 0); break; case "NORMAL": P(m, t[w], b.offset, a.array), a.stride = t[w].stride; break; case "COLOR": P(m, t[w], b.offset, c.array), c.stride = t[w].stride; break; case "TEXCOORD": P(m, t[w], b.offset, o.array), o.stride = t[w].stride; break; case "TEXCOORD1": P(m, t[w], b.offset, s.array), o.stride = t[w].stride; break; default: console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', E) } } break; case "NORMAL": P(m, t[b.id], b.offset, a.array), a.stride = t[b.id].stride; break; case "COLOR": P(m, t[b.id], b.offset, c.array), c.stride = t[b.id].stride; break; case "TEXCOORD": P(m, t[b.id], b.offset, o.array), o.stride = t[b.id].stride; break; case "TEXCOORD1": P(m, t[b.id], b.offset, s.array), s.stride = t[b.id].stride } } } r.array.length > 0 && u.addAttribute("position", new THREE.Float32BufferAttribute(r.array, r.stride)); a.array.length > 0 && u.addAttribute("normal", new THREE.Float32BufferAttribute(a.array, a.stride)); c.array.length > 0 && u.addAttribute("color", new THREE.Float32BufferAttribute(c.array, c.stride)); o.array.length > 0 && u.addAttribute("uv", new THREE.Float32BufferAttribute(o.array, o.stride)); s.array.length > 0 && u.addAttribute("uv2", new THREE.Float32BufferAttribute(s.array, s.stride)); l.array.length > 0 && u.addAttribute("skinIndex", new THREE.Float32BufferAttribute(l.array, l.stride)); h.array.length > 0 && u.addAttribute("skinWeight", new THREE.Float32BufferAttribute(h.array, h.stride)); return i.data = u, i.type = e[0].type, i.materialKeys = d, i }(s, n, i) } return t } function P(e, t, n, i) { function r(e) { for (var t = a[e + n] * l, r = t + l; t < r; t++)i.push(c[t]) } var a = e.p, o = e.stride, s = e.vcount, c = t.array, l = t.stride; if (void 0 !== e.vcount) for (var h = 0, u = 0, d = s.length; u < d; u++) { var p = s[u]; if (4 === p) { var f = h + 1 * o, m = h + 2 * o, g = h + 3 * o; r(x = h + 0 * o), r(f), r(g), r(f), r(m), r(g) } else if (3 === p) { var f = h + 1 * o, m = h + 2 * o; r(x = h + 0 * o), r(f), r(m) } else if (p > 4) for (var v = 1, y = p - 2; v <= y; v++) { var x = h + 0 * o, f = h + o * v, m = h + o * (v + 1); r(x), r(f), r(m) } h += o * p } else for (var u = 0, d = a.length; u < d; u += o)r(u) } function N(e) { return u(ce.geometries[e], C) } function I(e) { return void 0 !== e.build ? e.build : e } function D(e) { for (var t = { sid: e.getAttribute("sid"), name: e.getAttribute("name") || "", attachments: [], transforms: [] }, n = 0; n < e.childNodes.length; n++) { var i = e.childNodes[n]; if (1 === i.nodeType) switch (i.nodeName) { case "attachment_full": t.attachments.push(function (e) { for (var t = { joint: e.getAttribute("joint").split("/").pop(), transforms: [], links: [] }, n = 0; n < e.childNodes.length; n++) { var i = e.childNodes[n]; if (1 === i.nodeType) switch (i.nodeName) { case "link": t.links.push(D(i)); break; case "matrix": case "translate": case "rotate": t.transforms.push(O(i)) } } return t }(i)); break; case "matrix": case "translate": case "rotate": t.transforms.push(O(i)) } } return t } function O(e) { var t = { type: e.nodeName }, n = r(e.textContent); switch (t.type) { case "matrix": t.obj = new THREE.Matrix4, t.obj.fromArray(n).transpose(); break; case "translate": t.obj = new THREE.Vector3, t.obj.fromArray(n); break; case "rotate": t.obj = new THREE.Vector3, t.obj.fromArray(n), t.angle = THREE.MathUtils.degToRad(n[3]) }return t } function F(e) { return void 0 !== e.build ? e.build : e } function B(e) { for (var t = { name: e.getAttribute("name") || "", type: e.getAttribute("type"), id: e.getAttribute("id"), sid: e.getAttribute("sid"), matrix: new THREE.Matrix4, nodes: [], instanceCameras: [], instanceControllers: [], instanceLights: [], instanceGeometries: [], instanceNodes: [], transforms: {} }, n = 0; n < e.childNodes.length; n++) { var i = e.childNodes[n]; if (1 === i.nodeType) switch (i.nodeName) { case "node": t.nodes.push(i.getAttribute("id")), B(i); break; case "instance_camera": t.instanceCameras.push(o(i.getAttribute("url"))); break; case "instance_controller": t.instanceControllers.push(H(i)); break; case "instance_light": t.instanceLights.push(o(i.getAttribute("url"))); break; case "instance_geometry": t.instanceGeometries.push(H(i)); break; case "instance_node": t.instanceNodes.push(o(i.getAttribute("url"))); break; case "matrix": a = r(i.textContent); t.matrix.multiply(J.fromArray(a).transpose()), t.transforms[i.getAttribute("sid")] = i.nodeName; break; case "translate": a = r(i.textContent); Q.fromArray(a), t.matrix.multiply(J.makeTranslation(Q.x, Q.y, Q.z)), t.transforms[i.getAttribute("sid")] = i.nodeName; break; case "rotate": var a = r(i.textContent), s = THREE.MathUtils.degToRad(a[3]); t.matrix.multiply(J.makeRotationAxis(Q.fromArray(a), s)), t.transforms[i.getAttribute("sid")] = i.nodeName; break; case "scale": a = r(i.textContent); t.matrix.scale(Q.fromArray(a)), t.transforms[i.getAttribute("sid")] = i.nodeName; break; case "extra": break; default: console.log(i) } } return W(t.id) ? console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.", t.id) : ce.nodes[t.id] = t, t } function H(e) { for (var t = { id: o(e.getAttribute("url")), materials: {}, skeletons: [] }, n = 0; n < e.childNodes.length; n++) { var i = e.childNodes[n]; switch (i.nodeName) { case "bind_material": for (var r = i.getElementsByTagName("instance_material"), a = 0; a < r.length; a++) { var s = r[a], c = s.getAttribute("symbol"), l = s.getAttribute("target"); t.materials[c] = o(l) } break; case "skeleton": t.skeletons.push(o(i.textContent)) } } return t } function U(e, t) { var n, i, r = [], a = []; for (n = 0; n < e.length; n++) { var o = e[n]; if (W(o)) k(j(o), t, r); else if (function (e) { return void 0 !== ce.visualScenes[e] }(o)) for (var s = ce.visualScenes[o].children, c = 0; c < s.length; c++) { var l = s[c]; if ("JOINT" === l.type) { k(j(l.id), t, r) } } else console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:", o) } for (n = 0; n < t.length; n++)for (c = 0; c < r.length; c++)if ((i = r[c]).bone.name === t[n].name) { a[n] = i, i.processed = !0; break } for (n = 0; n < r.length; n++)!1 === (i = r[n]).processed && (a.push(i), i.processed = !0); var h = [], u = []; for (n = 0; n < a.length; n++)i = a[n], h.push(i.bone), u.push(i.boneInverse); return new THREE.Skeleton(h, u) } function k(e, t, n) { e.traverse(function (e) { if (!0 === e.isBone) { for (var i, r = 0; r < t.length; r++) { var a = t[r]; if (a.name === e.name) { i = a.boneInverse; break } } void 0 === i && (i = new THREE.Matrix4), n.push({ bone: e, boneInverse: i, processed: !1 }) } }) } function G(e) { for (var t = [], n = e.matrix, i = e.nodes, r = e.type, a = e.instanceCameras, o = e.instanceControllers, s = e.instanceLights, c = e.instanceGeometries, l = e.instanceNodes, h = 0, u = i.length; h < u; h++)t.push(j(i[h])); for (var h = 0, u = a.length; h < u; h++) { var d = T(a[h]); null !== d && t.push(d.clone()) } for (var h = 0, u = o.length; h < u; h++)for (var p = v((_ = o[h]).id), f = V(b = N(p.id), _.materials), m = U(_.skeletons, p.skin.joints), g = 0, y = f.length; g < y; g++) { (E = f[g]).isSkinnedMesh && (E.bind(m, p.skin.bindMatrix), E.normalizeSkinWeights()), t.push(E) } for (var h = 0, u = s.length; h < u; h++) { var x = A(s[h]); null !== x && t.push(x.clone()) } for (var h = 0, u = c.length; h < u; h++)for (var _ = c[h], b = N(_.id), g = 0, y = (f = V(b, _.materials)).length; g < y; g++)t.push(f[g]); for (var h = 0, u = l.length; h < u; h++)t.push(j(l[h]).clone()); var E; if (0 === i.length && 1 === t.length) E = t[0]; else { E = "JOINT" === r ? new THREE.Bone : new THREE.Group; for (h = 0; h < t.length; h++)E.add(t[h]) } return "" === E.name && (E.name = "JOINT" === r ? e.sid : e.name), E.matrix.copy(n), E.matrix.decompose(E.position, E.quaternion, E.scale), E } function z(e, t) { for (var n = [], i = 0, r = e.length; i < r; i++) { var a = t[e[i]]; void 0 === a ? (console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.", e[i]), n.push($)) : n.push(w(a)) } return n } function V(e, t) { var n = []; for (var i in e) { var r = e[i], a = z(r.materialKeys, t); 0 === a.length && ("lines" === i || "linestrips" === i ? a.push(new THREE.LineBasicMaterial) : a.push(new THREE.MeshPhongMaterial)); var o = void 0 !== r.data.attributes.skinIndex; if (o) for (var s = 0, c = a.length; s < c; s++)a[s].skinning = !0; var l, h = 1 === a.length ? a[0] : a; switch (i) { case "lines": l = new THREE.LineSegments(r.data, h); break; case "linestrips": l = new THREE.Line(r.data, h); break; case "triangles": case "polylist": l = o ? new THREE.SkinnedMesh(r.data, h) : new THREE.Mesh(r.data, h) }n.push(l) } return n } function W(e) { return void 0 !== ce.nodes[e] } function j(e) { return u(ce.nodes[e], G) } function X(e) { var t = new THREE.Group; t.name = e.name; for (var n = e.children, i = 0; i < n.length; i++) { var r = n[i]; t.add(j(r.id)) } return t } function q(e) { return u(ce.visualScenes[e], X) } var Y = new THREE.Vector3, K = new THREE.Vector3, Z = new THREE.Quaternion, J = new THREE.Matrix4, Q = new THREE.Vector3, $ = new THREE.MeshBasicMaterial({ color: 16711935 }); if (0 === e.length) return { scene: new THREE.Scene }; var ee = n((new DOMParser).parseFromString(e, "application/xml"), "COLLADA")[0], te = ee.getAttribute("version"); console.log("THREE.ColladaLoader: File version", te); var ne = function (e) { return { unit: function (e) { return void 0 !== e && !0 === e.hasAttribute("meter") ? parseFloat(e.getAttribute("meter")) : 1 }(n(e, "unit")[0]), upAxis: function (e) { return void 0 !== e ? e.textContent : "Y_UP" }(n(e, "up_axis")[0]) } }(n(ee, "asset")[0]), ie = new THREE.TextureLoader(this.manager); ie.setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin); var re; THREE.TGALoader && (re = new THREE.TGALoader(this.manager)).setPath(this.resourcePath || t); var ae = [], oe = {}, se = 0, ce = { animations: {}, clips: {}, controllers: {}, images: {}, effects: {}, materials: {}, cameras: {}, lights: {}, geometries: {}, nodes: {}, visualScenes: {}, kinematicsModels: {}, physicsModels: {}, kinematicsScenes: {} }; l(ee, "library_animations", "animation", function (e) { for (var t = { sources: {}, samplers: {}, channels: {} }, n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) { var a; switch (r.nodeName) { case "source": a = r.getAttribute("id"), t.sources[a] = R(r); break; case "sampler": a = r.getAttribute("id"), t.samplers[a] = function (e) { for (var t = { inputs: {} }, n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "input": var a = o(r.getAttribute("source")), s = r.getAttribute("semantic"); t.inputs[s] = a } } return t }(r); break; case "channel": a = r.getAttribute("target"), t.channels[a] = function (e) { var t = {}, n = e.getAttribute("target").split("/"), i = n.shift(), r = n.shift(), a = -1 !== r.indexOf("("), s = -1 !== r.indexOf("."); if (s) n = r.split("."), r = n.shift(), t.member = n.shift(); else if (a) { var c = r.split("("); r = c.shift(); for (var l = 0; l < c.length; l++)c[l] = parseInt(c[l].replace(/\)/, "")); t.indices = c } return t.id = i, t.sid = r, t.arraySyntax = a, t.memberSyntax = s, t.sampler = o(e.getAttribute("source")), t }(r); break; default: console.log(r) } } } ce.animations[e.getAttribute("id")] = t }), l(ee, "library_animation_clips", "animation_clip", function (e) { for (var t = { name: e.getAttribute("id") || "default", start: parseFloat(e.getAttribute("start") || 0), end: parseFloat(e.getAttribute("end") || 0), animations: [] }, n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "instance_animation": t.animations.push(o(r.getAttribute("url"))) } } ce.clips[e.getAttribute("id")] = t }), l(ee, "library_controllers", "controller", function (e) { for (var t = {}, n = 0, i = e.childNodes.length; n < i; n++) { var s = e.childNodes[n]; if (1 === s.nodeType) switch (s.nodeName) { case "skin": t.id = o(s.getAttribute("source")), t.skin = function (e) { for (var t = { sources: {} }, n = 0, i = e.childNodes.length; n < i; n++) { var s = e.childNodes[n]; if (1 === s.nodeType) switch (s.nodeName) { case "bind_shape_matrix": t.bindShapeMatrix = r(s.textContent); break; case "source": var c = s.getAttribute("id"); t.sources[c] = R(s); break; case "joints": t.joints = function (e) { for (var t = { inputs: {} }, n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "input": var a = r.getAttribute("semantic"), s = o(r.getAttribute("source")); t.inputs[a] = s } } return t }(s); break; case "vertex_weights": t.vertexWeights = function (e) { for (var t = { inputs: {} }, n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "input": var s = r.getAttribute("semantic"), c = o(r.getAttribute("source")), l = parseInt(r.getAttribute("offset")); t.inputs[s] = { id: c, offset: l }; break; case "vcount": t.vcount = a(r.textContent); break; case "v": t.v = a(r.textContent) } } return t }(s) } } return t }(s); break; case "morph": t.id = o(s.getAttribute("source")), console.warn("THREE.ColladaLoader: Morph target animation not supported yet.") } } ce.controllers[e.getAttribute("id")] = t }), l(ee, "library_images", "image", function (e) { var t = { init_from: n(e, "init_from")[0].textContent }; ce.images[e.getAttribute("id")] = t }), l(ee, "library_effects", "effect", function (e) { for (var t = {}, n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "profile_COMMON": t.profile = function (e) { for (var t = { surfaces: {}, samplers: {} }, n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "newparam": !function (e, t) { for (var n = e.getAttribute("sid"), i = 0, r = e.childNodes.length; i < r; i++) { var a = e.childNodes[i]; if (1 === a.nodeType) switch (a.nodeName) { case "surface": t.surfaces[n] = function (e) { for (var t = {}, n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "init_from": t.init_from = r.textContent } } return t }(a); break; case "sampler2D": t.samplers[n] = function (e) { for (var t = {}, n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "source": t.source = r.textContent } } return t }(a) } } }(r, t); break; case "technique": t.technique = function (e) { for (var t = {}, n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "constant": case "lambert": case "blinn": case "phong": t.type = r.nodeName, t.parameters = function (e) { for (var t = {}, n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "emission": case "diffuse": case "specular": case "bump": case "ambient": case "shininess": case "transparency": t[r.nodeName] = _(r); break; case "transparent": t[r.nodeName] = { opaque: r.getAttribute("opaque"), data: _(r) } } } return t }(r) } } return t }(r); break; case "extra": t.extra = function (e) { for (var t = {}, n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "technique": t.technique = function (e) { for (var t = {}, n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "double_sided": t[r.nodeName] = parseInt(r.textContent) } } return t }(r) } } return t }(r) } } return t }(r) } } ce.effects[e.getAttribute("id")] = t }), l(ee, "library_materials", "material", function (e) { for (var t = { name: e.getAttribute("name") }, n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "instance_effect": t.url = o(r.getAttribute("url")) } } ce.materials[e.getAttribute("id")] = t }), l(ee, "library_cameras", "camera", function (e) { for (var t = { name: e.getAttribute("name") }, n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "optics": t.optics = function (e) { for (var t = 0; t < e.childNodes.length; t++) { var n = e.childNodes[t]; switch (n.nodeName) { case "technique_common": return function (e) { for (var t = {}, n = 0; n < e.childNodes.length; n++) { var i = e.childNodes[n]; switch (i.nodeName) { case "perspective": case "orthographic": t.technique = i.nodeName, t.parameters = function (e) { for (var t = {}, n = 0; n < e.childNodes.length; n++) { var i = e.childNodes[n]; switch (i.nodeName) { case "xfov": case "yfov": case "xmag": case "ymag": case "znear": case "zfar": case "aspect_ratio": t[i.nodeName] = parseFloat(i.textContent) } } return t }(i) } } return t }(n) } } return {} }(r) } } ce.cameras[e.getAttribute("id")] = t }), l(ee, "library_lights", "light", function (e) { for (var t = {}, n = 0, i = e.childNodes.length; n < i; n++) { var a = e.childNodes[n]; if (1 === a.nodeType) switch (a.nodeName) { case "technique_common": t = function (e) { for (var t = {}, n = 0, i = e.childNodes.length; n < i; n++) { var a = e.childNodes[n]; if (1 === a.nodeType) switch (a.nodeName) { case "directional": case "point": case "spot": case "ambient": t.technique = a.nodeName, t.parameters = function (e) { for (var t = {}, n = 0, i = e.childNodes.length; n < i; n++) { var a = e.childNodes[n]; if (1 === a.nodeType) switch (a.nodeName) { case "color": var o = r(a.textContent); t.color = (new THREE.Color).fromArray(o); break; case "falloff_angle": t.falloffAngle = parseFloat(a.textContent); break; case "quadratic_attenuation": var s = parseFloat(a.textContent); t.distance = s ? Math.sqrt(1 / s) : 0 } } return t }(a) } } return t }(a) } } ce.lights[e.getAttribute("id")] = t }), l(ee, "library_geometries", "geometry", function (e) { var t = { name: e.getAttribute("name"), sources: {}, vertices: {}, primitives: [] }, i = n(e, "mesh")[0]; if (void 0 !== i) { for (var r = 0; r < i.childNodes.length; r++) { var s = i.childNodes[r]; if (1 === s.nodeType) { var c = s.getAttribute("id"); switch (s.nodeName) { case "source": t.sources[c] = R(s); break; case "vertices": t.vertices = function (e) { for (var t = {}, n = 0; n < e.childNodes.length; n++) { var i = e.childNodes[n]; 1 === i.nodeType && (t[i.getAttribute("semantic")] = o(i.getAttribute("source"))) } return t }(s); break; case "polygons": console.warn("THREE.ColladaLoader: Unsupported primitive type: ", s.nodeName); break; case "lines": case "linestrips": case "polylist": case "triangles": t.primitives.push(function (e) { for (var t = { type: e.nodeName, material: e.getAttribute("material"), count: parseInt(e.getAttribute("count")), inputs: {}, stride: 0, hasUV: !1 }, n = 0, i = e.childNodes.length; n < i; n++) { var r = e.childNodes[n]; if (1 === r.nodeType) switch (r.nodeName) { case "input": var s = o(r.getAttribute("source")), c = r.getAttribute("semantic"), l = parseInt(r.getAttribute("offset")), h = parseInt(r.getAttribute("set")), u = h > 0 ? c + h : c; t.inputs[u] = { id: s, offset: l }, t.stride = Math.max(t.stride, l + 1), "TEXCOORD" === c && (t.hasUV = !0); break; case "vcount": t.vcount = a(r.textContent); break; case "p": t.p = a(r.textContent) } } return t }(s)); break; default: console.log(s) } } } ce.geometries[e.getAttribute("id")] = t } }), l(ee, "library_nodes", "node", B), l(ee, "library_visual_scenes", "visual_scene", function (e) { var t = { name: e.getAttribute("name"), children: [] }; !function (e) { for (var t = e.getElementsByTagName("node"), n = 0; n < t.length; n++) { var i = t[n]; !1 === i.hasAttribute("id") && i.setAttribute("id", s()) } }(e); for (var i = n(e, "node"), r = 0; r < i.length; r++)t.children.push(B(i[r])); ce.visualScenes[e.getAttribute("id")] = t }), l(ee, "library_kinematics_models", "kinematics_model", function (e) { for (var t = { name: e.getAttribute("name") || "", joints: {}, links: [] }, n = 0; n < e.childNodes.length; n++) { var i = e.childNodes[n]; if (1 === i.nodeType) switch (i.nodeName) { case "technique_common": !function (e, t) { for (var n = 0; n < e.childNodes.length; n++) { var i = e.childNodes[n]; if (1 === i.nodeType) switch (i.nodeName) { case "joint": t.joints[i.getAttribute("sid")] = function (e) { for (var t, n = 0; n < e.childNodes.length; n++) { var i = e.childNodes[n]; if (1 === i.nodeType) switch (i.nodeName) { case "prismatic": case "revolute": t = function (e, t) { for (var t = { sid: e.getAttribute("sid"), name: e.getAttribute("name") || "", axis: new THREE.Vector3, limits: { min: 0, max: 0 }, type: e.nodeName, static: !1, zeroPosition: 0, middlePosition: 0 }, n = 0; n < e.childNodes.length; n++) { var i = e.childNodes[n]; if (1 === i.nodeType) switch (i.nodeName) { case "axis": var a = r(i.textContent); t.axis.fromArray(a); break; case "limits": var o = i.getElementsByTagName("max")[0], s = i.getElementsByTagName("min")[0]; t.limits.max = parseFloat(o.textContent), t.limits.min = parseFloat(s.textContent) } } return t.limits.min >= t.limits.max && (t.static = !0), t.middlePosition = (t.limits.min + t.limits.max) / 2, t }(i) } } return t }(i); break; case "link": t.links.push(D(i)) } } }(i, t) } } ce.kinematicsModels[e.getAttribute("id")] = t }), l(ee, "library_physics_models", "physics_model", function (e) { for (var t = { name: e.getAttribute("name") || "", rigidBodies: {} }, n = 0; n < e.childNodes.length; n++) { var i = e.childNodes[n]; if (1 === i.nodeType) switch (i.nodeName) { case "rigid_body": t.rigidBodies[i.getAttribute("name")] = {}, function (e, t) { for (var n = 0; n < e.childNodes.length; n++) { var i = e.childNodes[n]; if (1 === i.nodeType) switch (i.nodeName) { case "technique_common": !function (e, t) { for (var n = 0; n < e.childNodes.length; n++) { var i = e.childNodes[n]; if (1 === i.nodeType) switch (i.nodeName) { case "inertia": t.inertia = r(i.textContent); break; case "mass": t.mass = r(i.textContent)[0] } } }(i, t) } } }(i, t.rigidBodies[i.getAttribute("name")]) } } ce.physicsModels[e.getAttribute("id")] = t }), l(ee, "scene", "instance_kinematics_scene", function (e) { for (var t = { bindJointAxis: [] }, n = 0; n < e.childNodes.length; n++) { var i = e.childNodes[n]; if (1 === i.nodeType) switch (i.nodeName) { case "bind_joint_axis": t.bindJointAxis.push(function (e) { for (var t = { target: e.getAttribute("target").split("/").pop() }, n = 0; n < e.childNodes.length; n++) { var i = e.childNodes[n]; if (1 === i.nodeType) switch (i.nodeName) { case "axis": var r = i.getElementsByTagName("param")[0]; t.axis = r.textContent; var a = t.axis.split("inst_").pop().split("axis")[0]; t.jointIndex = a.substr(0, a.length - 1) } } return t }(i)) } } ce.kinematicsScenes[o(e.getAttribute("url"))] = t }), h(ce.animations, d), h(ce.clips, f), h(ce.controllers, g), h(ce.images, y), h(ce.effects, b), h(ce.materials, E), h(ce.cameras, M), h(ce.lights, S), h(ce.geometries, C), h(ce.visualScenes, X), function () { var e = ce.clips; if (!0 === c(e)) { if (!1 === c(ce.animations)) { var t = []; for (var n in ce.animations) for (var i = p(n), r = 0, a = i.length; r < a; r++)t.push(i[r]); ae.push(new THREE.AnimationClip("default", -1, t)) } } else for (var n in e) ae.push(m(n)) }(), function () { function e(e, t) { var n = t.getAttribute("name"), i = a.joints[e]; s.traverse(function (a) { a.name === n && (l[e] = { object: a, transforms: function (e) { for (var t = [], n = ee.querySelector('[id="' + e.id + '"]'), i = 0; i < n.childNodes.length; i++) { var a = n.childNodes[i]; if (1 === a.nodeType) switch (a.nodeName) { case "matrix": var o = r(a.textContent), s = (new THREE.Matrix4).fromArray(o).transpose(); t.push({ sid: a.getAttribute("sid"), type: a.nodeName, obj: s }); break; case "translate": case "scale": var o = r(a.textContent), c = (new THREE.Vector3).fromArray(o); t.push({ sid: a.getAttribute("sid"), type: a.nodeName, obj: c }); break; case "rotate": var o = r(a.textContent), c = (new THREE.Vector3).fromArray(o), l = THREE.MathUtils.degToRad(o[3]); t.push({ sid: a.getAttribute("sid"), type: a.nodeName, obj: c, angle: l }) } } return t }(t), joint: i, position: i.zeroPosition }) }) } var t = Object.keys(ce.kinematicsModels)[0], n = Object.keys(ce.kinematicsScenes)[0], i = Object.keys(ce.visualScenes)[0]; if (void 0 !== t && void 0 !== n) { for (var a = function (e) { return u(ce.kinematicsModels[e], I) }(t), o = function (e) { return u(ce.kinematicsScenes[e], F) }(n), s = q(i), c = o.bindJointAxis, l = {}, h = 0, d = c.length; h < d; h++) { var p = c[h], f = ee.querySelector('[sid="' + p.target + '"]'); if (f) { var m = f.parentElement; e(p.jointIndex, m) } } var g = new THREE.Matrix4; oe = { joints: a && a.joints, getJointValue: function (e) { var t = l[e]; if (t) return t.position; console.warn("THREE.ColladaLoader: Joint " + e + " doesn't exist.") }, setJointValue: function (e, t) { var n = l[e]; if (n) { var i = n.joint; if (t > i.limits.max || t < i.limits.min) console.warn("THREE.ColladaLoader: Joint " + e + " value " + t + " outside of limits (min: " + i.limits.min + ", max: " + i.limits.max + ")."); else if (i.static) console.warn("THREE.ColladaLoader: Joint " + e + " is static."); else { var r = n.object, a = i.axis, o = n.transforms; J.identity(); for (var s = 0; s < o.length; s++) { var c = o[s]; if (c.sid && -1 !== c.sid.indexOf(e)) switch (i.type) { case "revolute": J.multiply(g.makeRotationAxis(a, THREE.MathUtils.degToRad(t))); break; case "prismatic": J.multiply(g.makeTranslation(a.x * t, a.y * t, a.z * t)); break; default: console.warn("THREE.ColladaLoader: Unknown joint type: " + i.type) } else switch (c.type) { case "matrix": J.multiply(c.obj); break; case "translate": J.multiply(g.makeTranslation(c.obj.x, c.obj.y, c.obj.z)); break; case "scale": J.scale(c.obj); break; case "rotate": J.multiply(g.makeRotationAxis(c.obj, c.angle)) } } r.matrix.copy(J), r.matrix.decompose(r.position, r.quaternion, r.scale), l[e].position = t } } else console.log("THREE.ColladaLoader: " + e + " does not exist.") } } } }(); var le = function (e) { return q(o(n(e, "instance_visual_scene")[0].getAttribute("url"))) }(n(ee, "scene")[0]); return "Z_UP" === ne.upAxis && le.quaternion.setFromEuler(new THREE.Euler(-Math.PI / 2, 0, 0)), le.scale.multiplyScalar(ne.unit), { animations: ae, kinematics: oe, library: ce, scene: le } } } }, {}], 4: [function (e, t, n) { "use strict"; var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, r = "function" == typeof Symbol && "symbol" === i(Symbol.iterator) ? function (e) { return void 0 === e ? "undefined" : i(e) } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : void 0 === e ? "undefined" : i(e) }; t.exports = THREE.FBXLoader = function () { function e(e) { this.manager = void 0 !== e ? e : THREE.DefaultLoadingManager } function t(e) { this.textureLoader = e } function n() { } function i() { } function a() { } function o() { } function s(e, t) { this.dv = new DataView(e), this.offset = 0, this.littleEndian = void 0 === t || t } function c() { } function l(e) { var t = e.match(/FBXVersion: (\d+)/); if (t) { return parseInt(t[1]) } throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.") } function h(e) { return e / 46186158e3 } function u(e, t, n, i) { var r; switch (i.mappingType) { case "ByPolygonVertex": r = e; break; case "ByPolygon": r = t; break; case "ByVertice": r = n; break; case "AllSame": r = i.indices[0]; break; default: console.warn("THREE.FBXLoader: unknown attribute mapping type " + i.mappingType) }"IndexToDirect" === i.referenceType && (r = i.indices[r]); var a = r * i.dataSize, o = a + i.dataSize; return function (e, t, n, i) { for (var r = n, a = 0; r < i; r++, a++)e[a] = t[r]; return e }(_, i.buffer, a, o) } function d(e) { var t = new THREE.Matrix4; M.set(0, 0, 0), T.identity(); var n = p(e.eulerOrder ? e.eulerOrder : 0); if (e.translation && M.fromArray(e.translation), e.rotationOffset && M.add(w.fromArray(e.rotationOffset)), e.rotation) { (i = e.rotation.map(THREE.MathUtils.degToRad)).push(n), T.makeRotationFromEuler(E.fromArray(i)) } if (e.preRotation) { (i = e.preRotation.map(THREE.MathUtils.degToRad)).push(n), b.makeRotationFromEuler(E.fromArray(i)), T.premultiply(b) } if (e.postRotation) { var i = e.postRotation.map(THREE.MathUtils.degToRad); i.push(n), b.makeRotationFromEuler(E.fromArray(i)), b.getInverse(b), T.multiply(b) } return e.scale && t.scale(w.fromArray(e.scale)), t.setPosition(M), t.multiply(T), t } function p(e) { var t = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"]; return 6 === e ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), t[0]) : t[e] } function f(e) { return e.split(",").map(function (e) { return parseFloat(e) }) } function m(e, t, n) { return void 0 === t && (t = 0), void 0 === n && (n = e.byteLength), THREE.LoaderUtils.decodeText(new Uint8Array(e, t, n)) } function g(e, t, n) { return e.slice(0, t).concat(n).concat(e.slice(t)) } var v, y, x; e.prototype = { constructor: e, crossOrigin: "anonymous", load: function (e, t, n, i) { var r = this, a = THREE.LoaderUtils.extractUrlBase(e), o = new THREE.FileLoader(this.manager); o.setResponseType("arraybuffer"), o.load(e, function (n) { try { var o = r.parse(n, a); t(o) } catch (t) { setTimeout(function () { i && i(t), r.manager.itemError(e) }, 0) } }, n, i) }, setCrossOrigin: function (e) { return this.crossOrigin = e, this }, parse: function (e, n) { if (function (e) { var t = "Kaydara FBX Binary  \0"; return e.byteLength >= t.length && t === m(e, 0, t.length) }(e)) v = (new o).parse(e); else { var i = m(e); if (!function (e) { function t(t) { var n = e[t - 1]; return e = e.slice(i + t), i++, n } for (var n = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"], i = 0, r = 0; r < n.length; ++r)if (t(1) === n[r]) return !1; return !0 }(i)) throw new Error("THREE.FBXLoader: Unknown format."); if (l(i) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + l(i)); v = (new a).parse(i) } return new t(new THREE.TextureLoader(this.manager).setPath(n).setCrossOrigin(this.crossOrigin)).parse(v) } }, t.prototype = { constructor: t, parse: function () { y = this.parseConnections(); var e = this.parseImages(), t = this.parseTextures(e), i = this.parseMaterials(t), r = this.parseDeformers(), a = (new n).parse(r); return this.parseScene(r, a, i), x }, parseConnections: function () { var e = new Map; if ("Connections" in v) { v.Connections.connections.forEach(function (t) { var n = t[0], i = t[1], r = t[2]; e.has(n) || e.set(n, { parents: [], children: [] }); var a = { ID: i, relationship: r }; e.get(n).parents.push(a), e.has(i) || e.set(i, { parents: [], children: [] }); var o = { ID: n, relationship: r }; e.get(i).children.push(o) }) } return e }, parseImages: function () { var e = {}, t = {}; if ("Video" in v.Objects) { var n = v.Objects.Video; for (var i in n) { var r = n[i]; if (e[c = parseInt(i)] = r.RelativeFilename || r.Filename, "Content" in r) { var a = r.Content instanceof ArrayBuffer && r.Content.byteLength > 0, o = "string" == typeof r.Content && "" !== r.Content; if (a || o) { var s = this.parseImage(n[i]); t[r.RelativeFilename || r.Filename] = s } } } } for (var c in e) { var l = e[c]; void 0 !== t[l] ? e[c] = t[l] : e[c] = e[c].split("\\").pop() } return e }, parseImage: function (e) { var t, n = e.Content, i = e.RelativeFilename || e.Filename, r = i.slice(i.lastIndexOf(".") + 1).toLowerCase(); switch (r) { case "bmp": t = "image/bmp"; break; case "jpg": case "jpeg": t = "image/jpeg"; break; case "png": t = "image/png"; break; case "tif": t = "image/tiff"; break; case "tga": if ("function" != typeof THREE.TGALoader) return void console.warn("FBXLoader: THREE.TGALoader is required to load TGA textures"); null === THREE.Loader.Handlers.get(".tga") && THREE.Loader.Handlers.add(/\.tga$/i, new THREE.TGALoader), t = "image/tga"; break; default: return void console.warn('FBXLoader: Image type "' + r + '" is not supported.') }if ("string" == typeof n) return "data:" + t + ";base64," + n; var a = new Uint8Array(n); return window.URL.createObjectURL(new Blob([a], { type: t })) }, parseTextures: function (e) { var t = new Map; if ("Texture" in v.Objects) { var n = v.Objects.Texture; for (var i in n) { var r = this.parseTexture(n[i], e); t.set(parseInt(i), r) } } return t }, parseTexture: function (e, t) { var n = this.loadTexture(e, t); n.ID = e.id, n.name = e.attrName; var i = e.WrapModeU, r = e.WrapModeV, a = void 0 !== i ? i.value : 0, o = void 0 !== r ? r.value : 0; if (n.wrapS = 0 === a ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping, n.wrapT = 0 === o ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping, "Scaling" in e) { var s = e.Scaling.value; n.repeat.x = s[0], n.repeat.y = s[1] } return n }, loadTexture: function (e, t) { var n, i = this.textureLoader.path, r = y.get(e.id).children; void 0 !== r && r.length > 0 && void 0 !== t[r[0].ID] && (0 !== (n = t[r[0].ID]).indexOf("blob:") && 0 !== n.indexOf("data:") || this.textureLoader.setPath(void 0)); var a, o = e.FileName.slice(-3).toLowerCase(); if ("tga" === o) { var s = THREE.Loader.Handlers.get(".tga"); null === s ? (console.warn("FBXLoader: TGALoader not found, creating empty placeholder texture for", n), a = new THREE.Texture) : a = s.load(n) } else "psd" === o ? (console.warn("FBXLoader: PSD textures are not supported, creating empty placeholder texture for", n), a = new THREE.Texture) : a = this.textureLoader.load(n); return this.textureLoader.setPath(i), a }, parseMaterials: function (e) { var t = new Map; if ("Material" in v.Objects) { var n = v.Objects.Material; for (var i in n) { var r = this.parseMaterial(n[i], e); null !== r && t.set(parseInt(i), r) } } return t }, parseMaterial: function (e, t) { var n = e.id, i = e.attrName, a = e.ShadingModel; if ("object" === (void 0 === a ? "undefined" : r(a)) && (a = a.value), !y.has(n)) return null; var o, s = this.parseParameters(e, t, n); switch (a.toLowerCase()) { case "phong": o = new THREE.MeshPhongMaterial; break; case "lambert": o = new THREE.MeshLambertMaterial; break; default: console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', a), o = new THREE.MeshPhongMaterial({ color: 3342591 }) }return o.setValues(s), o.name = i, o }, parseParameters: function (e, t, n) { var i = {}; e.BumpFactor && (i.bumpScale = e.BumpFactor.value), e.Diffuse ? i.color = (new THREE.Color).fromArray(e.Diffuse.value) : e.DiffuseColor && "Color" === e.DiffuseColor.type && (i.color = (new THREE.Color).fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (i.displacementScale = e.DisplacementFactor.value), e.Emissive ? i.emissive = (new THREE.Color).fromArray(e.Emissive.value) : e.EmissiveColor && "Color" === e.EmissiveColor.type && (i.emissive = (new THREE.Color).fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (i.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (i.opacity = parseFloat(e.Opacity.value)), i.opacity < 1 && (i.transparent = !0), e.ReflectionFactor && (i.reflectivity = e.ReflectionFactor.value), e.Shininess && (i.shininess = e.Shininess.value), e.Specular ? i.specular = (new THREE.Color).fromArray(e.Specular.value) : e.SpecularColor && "Color" === e.SpecularColor.type && (i.specular = (new THREE.Color).fromArray(e.SpecularColor.value)); var r = this; return y.get(n).children.forEach(function (e) { var n = e.relationship; switch (n) { case "Bump": i.bumpMap = r.getTexture(t, e.ID); break; case "DiffuseColor": i.map = r.getTexture(t, e.ID); break; case "DisplacementColor": i.displacementMap = r.getTexture(t, e.ID); break; case "EmissiveColor": i.emissiveMap = r.getTexture(t, e.ID); break; case "NormalMap": i.normalMap = r.getTexture(t, e.ID); break; case "ReflectionColor": i.envMap = r.getTexture(t, e.ID), i.envMap.mapping = THREE.EquirectangularReflectionMapping; break; case "SpecularColor": i.specularMap = r.getTexture(t, e.ID); break; case "TransparentColor": i.alphaMap = r.getTexture(t, e.ID), i.transparent = !0; break; case "AmbientColor": case "ShininessExponent": case "SpecularFactor": case "VectorDisplacementColor": default: console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", n) } }), i }, getTexture: function (e, t) { return "LayeredTexture" in v.Objects && t in v.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = y.get(t).children[0].ID), e.get(t) }, parseDeformers: function () { var e = {}, t = {}; if ("Deformer" in v.Objects) { var n = v.Objects.Deformer; for (var i in n) { var r = n[i], a = y.get(parseInt(i)); if ("Skin" === r.attrType) { var o = this.parseSkeleton(a, n); o.ID = i, a.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), o.geometryID = a.parents[0].ID, e[i] = o } else if ("BlendShape" === r.attrType) { var s = { id: i }; s.rawTargets = this.parseMorphTargets(a, n), s.id = i, a.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[i] = s } } } return { skeletons: e, morphTargets: t } }, parseSkeleton: function (e, t) { var n = []; return e.children.forEach(function (e) { var i = t[e.ID]; if ("Cluster" === i.attrType) { var r = { ID: e.ID, indices: [], weights: [], transform: (new THREE.Matrix4).fromArray(i.Transform.a), transformLink: (new THREE.Matrix4).fromArray(i.TransformLink.a), linkMode: i.Mode }; "Indexes" in i && (r.indices = i.Indexes.a, r.weights = i.Weights.a), n.push(r) } }), { rawBones: n, bones: [] } }, parseMorphTargets: function (e, t) { for (var n = [], i = 0; i < e.children.length; i++) { if (8 === i) { console.warn("FBXLoader: maximum of 8 morph targets supported. Ignoring additional targets."); break } var r = e.children[i], a = t[r.ID], o = { name: a.attrName, initialWeight: a.DeformPercent, id: a.id, fullWeights: a.FullWeights.a }; if ("BlendShapeChannel" !== a.attrType) return; y.get(parseInt(r.ID)).children.forEach(function (e) { void 0 === e.relationship && (o.geoID = e.ID) }), n.push(o) } return n }, parseScene: function (e, t, n) { x = new THREE.Group; var r = this.parseModels(e.skeletons, t, n), a = v.Objects.Model, o = this; r.forEach(function (e) { var t = a[e.ID]; o.setLookAtProperties(e, t); y.get(e.ID).parents.forEach(function (t) { var n = r.get(t.ID); void 0 !== n && n.add(e) }), null === e.parent && x.add(e) }), this.bindSkeleton(e.skeletons, t, r), this.createAmbientLight(), this.setupMorphMaterials(); var s = (new i).parse(); 1 === x.children.length && x.children[0].isGroup && (x.children[0].animations = s, x = x.children[0]), x.animations = s }, parseModels: function (e, t, n) { var i = new Map, r = v.Objects.Model; for (var a in r) { var o = parseInt(a), s = r[a], c = y.get(o), l = this.buildSkeleton(c, e, o, s.attrName); if (!l) { switch (s.attrType) { case "Camera": l = this.createCamera(c); break; case "Light": l = this.createLight(c); break; case "Mesh": l = this.createMesh(c, t, n); break; case "NurbsCurve": l = this.createCurve(c, t); break; case "LimbNode": case "Null": default: l = new THREE.Group }l.name = THREE.PropertyBinding.sanitizeNodeName(s.attrName), l.ID = o } this.setModelTransforms(l, s), i.set(o, l) } return i }, buildSkeleton: function (e, t, n, i) { var r = null; return e.parents.forEach(function (e) { for (var a in t) { var o = t[a]; o.rawBones.forEach(function (t, a) { if (t.ID === e.ID) { var s = r; (r = new THREE.Bone).matrixWorld.copy(t.transformLink), r.name = THREE.PropertyBinding.sanitizeNodeName(i), r.ID = n, o.bones[a] = r, null !== s && r.add(s) } }) } }), r }, createCamera: function (e) { var t, n; if (e.children.forEach(function (e) { var t = v.Objects.NodeAttribute[e.ID]; void 0 !== t && (n = t) }), void 0 === n) t = new THREE.Object3D; else { var i = 0; void 0 !== n.CameraProjectionType && 1 === n.CameraProjectionType.value && (i = 1); var r = 1; void 0 !== n.NearPlane && (r = n.NearPlane.value / 1e3); var a = 1e3; void 0 !== n.FarPlane && (a = n.FarPlane.value / 1e3); var o = window.innerWidth, s = window.innerHeight; void 0 !== n.AspectWidth && void 0 !== n.AspectHeight && (o = n.AspectWidth.value, s = n.AspectHeight.value); var c = o / s, l = 45; void 0 !== n.FieldOfView && (l = n.FieldOfView.value); var h = n.FocalLength ? n.FocalLength.value : null; switch (i) { case 0: t = new THREE.PerspectiveCamera(l, c, r, a), null !== h && t.setFocalLength(h); break; case 1: t = new THREE.OrthographicCamera(-o / 2, o / 2, s / 2, -s / 2, r, a); break; default: console.warn("THREE.FBXLoader: Unknown camera type " + i + "."), t = new THREE.Object3D } } return t }, createLight: function (e) { var t, n; if (e.children.forEach(function (e) { var t = v.Objects.NodeAttribute[e.ID]; void 0 !== t && (n = t) }), void 0 === n) t = new THREE.Object3D; else { var i; i = void 0 === n.LightType ? 0 : n.LightType.value; var r = 16777215; void 0 !== n.Color && (r = (new THREE.Color).fromArray(n.Color.value)); var a = void 0 === n.Intensity ? 1 : n.Intensity.value / 100; void 0 !== n.CastLightOnObject && 0 === n.CastLightOnObject.value && (a = 0); var o = 0; void 0 !== n.FarAttenuationEnd && (o = void 0 !== n.EnableFarAttenuation && 0 === n.EnableFarAttenuation.value ? 0 : n.FarAttenuationEnd.value); switch (i) { case 0: t = new THREE.PointLight(r, a, o, 1); break; case 1: t = new THREE.DirectionalLight(r, a); break; case 2: var s = Math.PI / 3; void 0 !== n.InnerAngle && (s = THREE.MathUtils.degToRad(n.InnerAngle.value)); var c = 0; void 0 !== n.OuterAngle && (c = THREE.MathUtils.degToRad(n.OuterAngle.value), c = Math.max(c, 1)), t = new THREE.SpotLight(r, a, o, s, c, 1); break; default: console.warn("THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a THREE.PointLight."), t = new THREE.PointLight(r, a) }void 0 !== n.CastShadows && 1 === n.CastShadows.value && (t.castShadow = !0) } return t }, createMesh: function (e, t, n) { var i, r = null, a = null, o = []; return e.children.forEach(function (e) { t.has(e.ID) && (r = t.get(e.ID)), n.has(e.ID) && o.push(n.get(e.ID)) }), o.length > 1 ? a = o : o.length > 0 ? a = o[0] : (a = new THREE.MeshPhongMaterial({ color: 13421772 }), o.push(a)), "color" in r.attributes && o.forEach(function (e) { e.vertexColors = THREE.VertexColors }), r.FBX_Deformer ? (o.forEach(function (e) { e.skinning = !0 }), i = new THREE.SkinnedMesh(r, a)) : i = new THREE.Mesh(r, a), i }, createCurve: function (e, t) { var n = e.children.reduce(function (e, n) { return t.has(n.ID) && (e = t.get(n.ID)), e }, null), i = new THREE.LineBasicMaterial({ color: 3342591, linewidth: 1 }); return new THREE.Line(n, i) }, setModelTransforms: function (e, t) { var n = {}; "RotationOrder" in t && (n.eulerOrder = parseInt(t.RotationOrder.value)), "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value), "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value), "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value), "PreRotation" in t && (n.preRotation = t.PreRotation.value), "PostRotation" in t && (n.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value); var i = d(n); e.applyMatrix(i) }, setLookAtProperties: function (e, t) { if ("LookAtProperty" in t) { y.get(e.ID).children.forEach(function (t) { if ("LookAtProperty" === t.relationship) { var n = v.Objects.Model[t.ID]; if ("Lcl_Translation" in n) { var i = n.Lcl_Translation.value; void 0 !== e.target ? (e.target.position.fromArray(i), x.add(e.target)) : e.lookAt((new THREE.Vector3).fromArray(i)) } } }) } }, bindSkeleton: function (e, t, n) { var i = this.parsePoseNodes(); for (var r in e) { var a = e[r]; y.get(parseInt(a.ID)).parents.forEach(function (e) { if (t.has(e.ID)) { var r = e.ID; y.get(r).parents.forEach(function (e) { if (n.has(e.ID)) { n.get(e.ID).bind(new THREE.Skeleton(a.bones), i[e.ID]) } }) } }) } }, parsePoseNodes: function () { var e = {}; if ("Pose" in v.Objects) { var t = v.Objects.Pose; for (var n in t) if ("BindPose" === t[n].attrType) { var i = t[n].PoseNode; Array.isArray(i) ? i.forEach(function (t) { e[t.Node] = (new THREE.Matrix4).fromArray(t.Matrix.a) }) : e[i.Node] = (new THREE.Matrix4).fromArray(i.Matrix.a) } } return e }, createAmbientLight: function () { if ("GlobalSettings" in v && "AmbientColor" in v.GlobalSettings) { var e = v.GlobalSettings.AmbientColor.value, t = e[0], n = e[1], i = e[2]; if (0 !== t || 0 !== n || 0 !== i) { var r = new THREE.Color(t, n, i); x.add(new THREE.AmbientLight(r, 1)) } } }, setupMorphMaterials: function () { x.traverse(function (e) { if (e.isMesh && (e.geometry.morphAttributes.position || e.geometry.morphAttributes.normal)) { var t = e.uuid, n = e.material.uuid, i = !1; x.traverse(function (e) { e.isMesh && e.material.uuid === n && e.uuid !== t && (i = !0) }), !0 === i && (e.material = e.material.clone()), e.material.morphTargets = !0 } }) } }, n.prototype = { constructor: n, parse: function (e) { var t = new Map; if ("Geometry" in v.Objects) { var n = v.Objects.Geometry; for (var i in n) { var r = y.get(parseInt(i)), a = this.parseGeometry(r, n[i], e); t.set(parseInt(i), a) } } return t }, parseGeometry: function (e, t, n) { switch (t.attrType) { case "Mesh": return this.parseMeshGeometry(e, t, n); case "NurbsCurve": return this.parseNurbsGeometry(t) } }, parseMeshGeometry: function (e, t, n) { var i = n.skeletons, r = n.morphTargets, a = e.parents.map(function (e) { return v.Objects.Model[e.ID] }); if (0 !== a.length) { var o = e.children.reduce(function (e, t) { return void 0 !== i[t.ID] && (e = i[t.ID]), e }, null), s = e.children.reduce(function (e, t) { return void 0 !== r[t.ID] && (e = r[t.ID]), e }, null), c = a[0], l = {}; "RotationOrder" in c && (l.eulerOrder = c.RotationOrder.value), "GeometricTranslation" in c && (l.translation = c.GeometricTranslation.value), "GeometricRotation" in c && (l.rotation = c.GeometricRotation.value), "GeometricScaling" in c && (l.scale = c.GeometricScaling.value); var h = d(l); return this.genGeometry(t, o, s, h) } }, genGeometry: function (e, t, n, i) { var r = new THREE.BufferGeometry; e.attrName && (r.name = e.attrName); var a = this.parseGeoNode(e, t), o = this.genBuffers(a), s = new THREE.Float32BufferAttribute(o.vertex, 3); if (i.applyToBufferAttribute(s), r.addAttribute("position", s), o.colors.length > 0 && r.addAttribute("color", new THREE.Float32BufferAttribute(o.colors, 3)), t && (r.addAttribute("skinIndex", new THREE.Uint16BufferAttribute(o.weightsIndices, 4)), r.addAttribute("skinWeight", new THREE.Float32BufferAttribute(o.vertexWeights, 4)), r.FBX_Deformer = t), o.normal.length > 0) { var c = new THREE.Float32BufferAttribute(o.normal, 3); (new THREE.Matrix3).getNormalMatrix(i).applyToBufferAttribute(c), r.addAttribute("normal", c) } if (o.uvs.forEach(function (e, t) { var n = "uv" + (t + 1).toString(); 0 === t && (n = "uv"), r.addAttribute(n, new THREE.Float32BufferAttribute(o.uvs[t], 2)) }), a.material && "AllSame" !== a.material.mappingType) { var l = o.materialIndex[0], h = 0; if (o.materialIndex.forEach(function (e, t) { e !== l && (r.addGroup(h, t - h, l), l = e, h = t) }), r.groups.length > 0) { var u = r.groups[r.groups.length - 1], d = u.start + u.count; d !== o.materialIndex.length && r.addGroup(d, o.materialIndex.length - d, l) } 0 === r.groups.length && r.addGroup(0, o.materialIndex.length, o.materialIndex[0]) } return this.addMorphTargets(r, e, n, i), r }, parseGeoNode: function (e, t) { var n = {}; if (n.vertexPositions = void 0 !== e.Vertices ? e.Vertices.a : [], n.vertexIndices = void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) { n.uv = []; for (var i = 0; e.LayerElementUV[i];)n.uv.push(this.parseUVs(e.LayerElementUV[i])), i++ } return n.weightTable = {}, null !== t && (n.skeleton = t, t.rawBones.forEach(function (e, t) { e.indices.forEach(function (i, r) { void 0 === n.weightTable[i] && (n.weightTable[i] = []), n.weightTable[i].push({ id: t, weight: e.weights[r] }) }) })), n }, genBuffers: function (e) { var t = { vertex: [], normal: [], colors: [], uvs: [], materialIndex: [], vertexWeights: [], weightsIndices: [] }, n = 0, i = 0, r = !1, a = [], o = [], s = [], c = [], l = [], h = [], d = this; return e.vertexIndices.forEach(function (p, f) { var m = !1; p < 0 && (p ^= -1, m = !0); var g = [], v = []; if (a.push(3 * p, 3 * p + 1, 3 * p + 2), e.color) { b = u(f, n, p, e.color); s.push(b[0], b[1], b[2]) } if (e.skeleton) { if (void 0 !== e.weightTable[p] && e.weightTable[p].forEach(function (e) { v.push(e.weight), g.push(e.id) }), v.length > 4) { r || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), r = !0); var y = [0, 0, 0, 0], x = [0, 0, 0, 0]; v.forEach(function (e, t) { var n = e, i = g[t]; x.forEach(function (e, t, r) { if (n > e) { r[t] = n, n = e; var a = y[t]; y[t] = i, i = a } }) }), g = y, v = x } for (; v.length < 4;)v.push(0), g.push(0); for (var _ = 0; _ < 4; ++_)l.push(v[_]), h.push(g[_]) } if (e.normal) { var b = u(f, n, p, e.normal); o.push(b[0], b[1], b[2]) } if (e.material && "AllSame" !== e.material.mappingType) var E = u(f, n, p, e.material)[0]; e.uv && e.uv.forEach(function (e, t) { var i = u(f, n, p, e); void 0 === c[t] && (c[t] = []), c[t].push(i[0]), c[t].push(i[1]) }), i++, m && (d.genFace(t, e, a, E, o, s, c, l, h, i), n++, i = 0, a = [], o = [], s = [], c = [], l = [], h = []) }), t }, genFace: function (e, t, n, i, r, a, o, s, c, l) { for (var h = 2; h < l; h++)e.vertex.push(t.vertexPositions[n[0]]), e.vertex.push(t.vertexPositions[n[1]]), e.vertex.push(t.vertexPositions[n[2]]), e.vertex.push(t.vertexPositions[n[3 * (h - 1)]]), e.vertex.push(t.vertexPositions[n[3 * (h - 1) + 1]]), e.vertex.push(t.vertexPositions[n[3 * (h - 1) + 2]]), e.vertex.push(t.vertexPositions[n[3 * h]]), e.vertex.push(t.vertexPositions[n[3 * h + 1]]), e.vertex.push(t.vertexPositions[n[3 * h + 2]]), t.skeleton && (e.vertexWeights.push(s[0]), e.vertexWeights.push(s[1]), e.vertexWeights.push(s[2]), e.vertexWeights.push(s[3]), e.vertexWeights.push(s[4 * (h - 1)]), e.vertexWeights.push(s[4 * (h - 1) + 1]), e.vertexWeights.push(s[4 * (h - 1) + 2]), e.vertexWeights.push(s[4 * (h - 1) + 3]), e.vertexWeights.push(s[4 * h]), e.vertexWeights.push(s[4 * h + 1]), e.vertexWeights.push(s[4 * h + 2]), e.vertexWeights.push(s[4 * h + 3]), e.weightsIndices.push(c[0]), e.weightsIndices.push(c[1]), e.weightsIndices.push(c[2]), e.weightsIndices.push(c[3]), e.weightsIndices.push(c[4 * (h - 1)]), e.weightsIndices.push(c[4 * (h - 1) + 1]), e.weightsIndices.push(c[4 * (h - 1) + 2]), e.weightsIndices.push(c[4 * (h - 1) + 3]), e.weightsIndices.push(c[4 * h]), e.weightsIndices.push(c[4 * h + 1]), e.weightsIndices.push(c[4 * h + 2]), e.weightsIndices.push(c[4 * h + 3])), t.color && (e.colors.push(a[0]), e.colors.push(a[1]), e.colors.push(a[2]), e.colors.push(a[3 * (h - 1)]), e.colors.push(a[3 * (h - 1) + 1]), e.colors.push(a[3 * (h - 1) + 2]), e.colors.push(a[3 * h]), e.colors.push(a[3 * h + 1]), e.colors.push(a[3 * h + 2])), t.material && "AllSame" !== t.material.mappingType && (e.materialIndex.push(i), e.materialIndex.push(i), e.materialIndex.push(i)), t.normal && (e.normal.push(r[0]), e.normal.push(r[1]), e.normal.push(r[2]), e.normal.push(r[3 * (h - 1)]), e.normal.push(r[3 * (h - 1) + 1]), e.normal.push(r[3 * (h - 1) + 2]), e.normal.push(r[3 * h]), e.normal.push(r[3 * h + 1]), e.normal.push(r[3 * h + 2])), t.uv && t.uv.forEach(function (t, n) { void 0 === e.uvs[n] && (e.uvs[n] = []), e.uvs[n].push(o[n][0]), e.uvs[n].push(o[n][1]), e.uvs[n].push(o[n][2 * (h - 1)]), e.uvs[n].push(o[n][2 * (h - 1) + 1]), e.uvs[n].push(o[n][2 * h]), e.uvs[n].push(o[n][2 * h + 1]) }) }, addMorphTargets: function (e, t, n, i) { if (null !== n) { e.morphAttributes.position = [], e.morphAttributes.normal = []; var r = this; n.rawTargets.forEach(function (n) { var a = v.Objects.Geometry[n.geoID]; void 0 !== a && r.genMorphGeometry(e, t, a, i) }) } }, genMorphGeometry: function (e, t, n, i) { var r = new THREE.BufferGeometry; n.attrName && (r.name = n.attrName); for (var a = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [], o = void 0 !== t.Vertices ? t.Vertices.a.slice() : [], s = void 0 !== n.Vertices ? n.Vertices.a : [], c = void 0 !== n.Indexes ? n.Indexes.a : [], l = 0; l < c.length; l++) { var h = 3 * c[l]; o[h] += s[3 * l], o[h + 1] += s[3 * l + 1], o[h + 2] += s[3 * l + 2] } var u = { vertexIndices: a, vertexPositions: o }, d = this.genBuffers(u), p = new THREE.Float32BufferAttribute(d.vertex, 3); p.name = n.attrName, i.applyToBufferAttribute(p), e.morphAttributes.position.push(p) }, parseNormals: function (e) { var t = e.MappingInformationType, n = e.ReferenceInformationType, i = e.Normals.a, r = []; return "IndexToDirect" === n && ("NormalIndex" in e ? r = e.NormalIndex.a : "NormalsIndex" in e && (r = e.NormalsIndex.a)), { dataSize: 3, buffer: i, indices: r, mappingType: t, referenceType: n } }, parseUVs: function (e) { var t = e.MappingInformationType, n = e.ReferenceInformationType, i = e.UV.a, r = []; return "IndexToDirect" === n && (r = e.UVIndex.a), { dataSize: 2, buffer: i, indices: r, mappingType: t, referenceType: n } }, parseVertexColors: function (e) { var t = e.MappingInformationType, n = e.ReferenceInformationType, i = e.Colors.a, r = []; return "IndexToDirect" === n && (r = e.ColorIndex.a), { dataSize: 4, buffer: i, indices: r, mappingType: t, referenceType: n } }, parseMaterialIndices: function (e) { var t = e.MappingInformationType, n = e.ReferenceInformationType; if ("NoMappingInformation" === t) return { dataSize: 1, buffer: [0], indices: [0], mappingType: "AllSame", referenceType: n }; for (var i = e.Materials.a, r = [], a = 0; a < i.length; ++a)r.push(a); return { dataSize: 1, buffer: i, indices: r, mappingType: t, referenceType: n } }, parseNurbsGeometry: function (e) { if (void 0 === THREE.NURBSCurve) return console.error("THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new THREE.BufferGeometry; var t = parseInt(e.Order); if (isNaN(t)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new THREE.BufferGeometry; for (var n = t - 1, i = e.KnotVector.a, r = [], a = e.Points.a, o = 0, s = a.length; o < s; o += 4)r.push((new THREE.Vector4).fromArray(a, o)); var c, l; if ("Closed" === e.Form) r.push(r[0]); else if ("Periodic" === e.Form) { c = n, l = i.length - 1 - c; for (o = 0; o < n; ++o)r.push(r[o]) } var h = new THREE.NURBSCurve(n, i, r, c, l).getPoints(7 * r.length), u = new Float32Array(3 * h.length); h.forEach(function (e, t) { e.toArray(u, 3 * t) }); var d = new THREE.BufferGeometry; return d.addAttribute("position", new THREE.BufferAttribute(u, 3)), d } }, i.prototype = { constructor: i, parse: function () { var e = [], t = this.parseClips(); if (void 0 === t) return e; for (var n in t) { var i = t[n], r = this.addClip(i); e.push(r) } return e }, parseClips: function () { if (void 0 !== v.Objects.AnimationCurve) { var e = this.parseAnimationCurveNodes(); this.parseAnimationCurves(e); var t = this.parseAnimationLayers(e); return this.parseAnimStacks(t) } }, parseAnimationCurveNodes: function () { var e = v.Objects.AnimationCurveNode, t = new Map; for (var n in e) { var i = e[n]; if (null !== i.attrName.match(/S|R|T|DeformPercent/)) { var r = { id: i.id, attr: i.attrName, curves: {} }; t.set(r.id, r) } } return t }, parseAnimationCurves: function (e) { var t = v.Objects.AnimationCurve; for (var n in t) { var i = { id: t[n].id, times: t[n].KeyTime.a.map(h), values: t[n].KeyValueFloat.a }, r = y.get(i.id); if (void 0 !== r) { var a = r.parents[0].ID, o = r.parents[0].relationship; o.match(/X/) ? e.get(a).curves.x = i : o.match(/Y/) ? e.get(a).curves.y = i : o.match(/Z/) ? e.get(a).curves.z = i : o.match(/d|DeformPercent/) && e.has(a) && (e.get(a).curves.morph = i) } } }, parseAnimationLayers: function (e) { var t = v.Objects.AnimationLayer, n = new Map; for (var i in t) { var r = [], a = y.get(parseInt(i)); if (void 0 !== a) { var o = this; a.children.forEach(function (t, n) { if (e.has(t.ID)) { var i = e.get(t.ID); if (void 0 !== i.curves.x || void 0 !== i.curves.y || void 0 !== i.curves.z) { if (void 0 === r[n]) { y.get(t.ID).parents.forEach(function (e) { void 0 !== e.relationship && (u = e.ID) }); var a = v.Objects.Model[u.toString()], s = { modelName: THREE.PropertyBinding.sanitizeNodeName(a.attrName), initialPosition: [0, 0, 0], initialRotation: [0, 0, 0], initialScale: [1, 1, 1], transform: o.getModelAnimTransform(a) }; "PreRotation" in a && (s.preRotations = a.PreRotation.value), "PostRotation" in a && (s.postRotations = a.PostRotation.value), r[n] = s } r[n][i.attr] = i } else if (void 0 !== i.curves.morph) { if (void 0 === r[n]) { var c; y.get(t.ID).parents.forEach(function (e) { void 0 !== e.relationship && (c = e.ID) }); var l = y.get(c).parents[0].ID, h = y.get(l).parents[0].ID, u = y.get(h).parents[0].ID, a = v.Objects.Model[u], s = { modelName: THREE.PropertyBinding.sanitizeNodeName(a.attrName), morphName: v.Objects.Deformer[c].attrName }; r[n] = s } r[n][i.attr] = i } } }), n.set(parseInt(i), r) } } return n }, getModelAnimTransform: function (e) { var t = {}; return "RotationOrder" in e && (t.eulerOrder = parseInt(e.RotationOrder.value)), "Lcl_Translation" in e && (t.translation = e.Lcl_Translation.value), "RotationOffset" in e && (t.rotationOffset = e.RotationOffset.value), "Lcl_Rotation" in e && (t.rotation = e.Lcl_Rotation.value), "PreRotation" in e && (t.preRotation = e.PreRotation.value), "PostRotation" in e && (t.postRotation = e.PostRotation.value), "Lcl_Scaling" in e && (t.scale = e.Lcl_Scaling.value), d(t) }, parseAnimStacks: function (e) { var t = v.Objects.AnimationStack, n = {}; for (var i in t) { var r = y.get(parseInt(i)).children; r.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."); var a = e.get(r[0].ID); n[i] = { name: t[i].attrName, layer: a } } return n }, addClip: function (e) { var t = [], n = this; return e.layer.forEach(function (e) { t = t.concat(n.generateTracks(e)) }), new THREE.AnimationClip(e.name, -1, t) }, generateTracks: function (e) { var t = [], n = new THREE.Vector3, i = new THREE.Quaternion, r = new THREE.Vector3; if (e.transform && e.transform.decompose(n, i, r), n = n.toArray(), i = (new THREE.Euler).setFromQuaternion(i).toArray(), r = r.toArray(), void 0 !== e.T && Object.keys(e.T.curves).length > 0) { var a = this.generateVectorTrack(e.modelName, e.T.curves, n, "position"); void 0 !== a && t.push(a) } if (void 0 !== e.R && Object.keys(e.R.curves).length > 0) { var o = this.generateRotationTrack(e.modelName, e.R.curves, i, e.preRotations, e.postRotations); void 0 !== o && t.push(o) } if (void 0 !== e.S && Object.keys(e.S.curves).length > 0) { var s = this.generateVectorTrack(e.modelName, e.S.curves, r, "scale"); void 0 !== s && t.push(s) } if (void 0 !== e.DeformPercent) { var c = this.generateMorphTrack(e); void 0 !== c && t.push(c) } return t }, generateVectorTrack: function (e, t, n, i) { var r = this.getTimesForAllAxes(t), a = this.getKeyframeTrackValues(r, t, n); return new THREE.VectorKeyframeTrack(e + "." + i, r, a) }, generateRotationTrack: function (e, t, n, i, r) { void 0 !== t.x && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(THREE.MathUtils.degToRad)), void 0 !== t.y && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(THREE.MathUtils.degToRad)), void 0 !== t.z && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(THREE.MathUtils.degToRad)); var a = this.getTimesForAllAxes(t), o = this.getKeyframeTrackValues(a, t, n); void 0 !== i && ((i = i.map(THREE.MathUtils.degToRad)).push("ZYX"), i = (new THREE.Euler).fromArray(i), i = (new THREE.Quaternion).setFromEuler(i)), void 0 !== r && ((r = r.map(THREE.MathUtils.degToRad)).push("ZYX"), r = (new THREE.Euler).fromArray(r), r = (new THREE.Quaternion).setFromEuler(r).inverse()); for (var s = new THREE.Quaternion, c = new THREE.Euler, l = [], h = 0; h < o.length; h += 3)c.set(o[h], o[h + 1], o[h + 2], "ZYX"), s.setFromEuler(c), void 0 !== i && s.premultiply(i), void 0 !== r && s.multiply(r), s.toArray(l, h / 3 * 4); return new THREE.QuaternionKeyframeTrack(e + ".quaternion", a, l) }, generateMorphTrack: function (e) { var t = e.DeformPercent.curves.morph, n = t.values.map(function (e) { return e / 100 }), i = x.getObjectByName(e.modelName).morphTargetDictionary[e.morphName]; return new THREE.NumberKeyframeTrack(e.modelName + ".morphTargetInfluences[" + i + "]", t.times, n) }, getTimesForAllAxes: function (e) { var t = []; return void 0 !== e.x && (t = t.concat(e.x.times)), void 0 !== e.y && (t = t.concat(e.y.times)), void 0 !== e.z && (t = t.concat(e.z.times)), t = t.sort(function (e, t) { return e - t }).filter(function (e, t, n) { return n.indexOf(e) == t }) }, getKeyframeTrackValues: function (e, t, n) { var i = n, r = [], a = -1, o = -1, s = -1; return e.forEach(function (e) { if (t.x && (a = t.x.times.indexOf(e)), t.y && (o = t.y.times.indexOf(e)), t.z && (s = t.z.times.indexOf(e)), -1 !== a) { var n = t.x.values[a]; r.push(n), i[0] = n } else r.push(i[0]); if (-1 !== o) { var c = t.y.values[o]; r.push(c), i[1] = c } else r.push(i[1]); if (-1 !== s) { var l = t.z.values[s]; r.push(l), i[2] = l } else r.push(i[2]) }), r }, interpolateRotations: function (e) { for (var t = 1; t < e.values.length; t++) { var n = e.values[t - 1], i = e.values[t] - n, r = Math.abs(i); if (r >= 180) { for (var a = r / 180, o = i / a, s = n + o, c = e.times[t - 1], l = (e.times[t] - c) / a, h = c + l, u = [], d = []; h < e.times[t];)u.push(h), h += l, d.push(s), s += o; e.times = g(e.times, t, u), e.values = g(e.values, t, d) } } } }, a.prototype = { constructor: a, getPrevNode: function () { return this.nodeStack[this.currentIndent - 2] }, getCurrentNode: function () { return this.nodeStack[this.currentIndent - 1] }, getCurrentProp: function () { return this.currentProp }, pushStack: function (e) { this.nodeStack.push(e), this.currentIndent += 1 }, popStack: function () { this.nodeStack.pop(), this.currentIndent -= 1 }, setCurrentProp: function (e, t) { this.currentProp = e, this.currentPropName = t }, parse: function (e) { this.currentIndent = 0, console.log("FBXTree: ", c), this.allNodes = new c, this.nodeStack = [], this.currentProp = [], this.currentPropName = ""; var t = this, n = e.split(/[\r\n]+/); return n.forEach(function (e, i) { var r = e.match(/^[\s\t]*;/), a = e.match(/^[\s\t]*$/); if (!r && !a) { var o = e.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), s = e.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), c = e.match("^\\t{" + (t.currentIndent - 1) + "}}"); o ? t.parseNodeBegin(e, o) : s ? t.parseNodeProperty(e, s, n[++i]) : c ? t.popStack() : e.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(e) } }), this.allNodes }, parseNodeBegin: function (e, t) { var n = t[1].trim().replace(/^"/, "").replace(/"$/, ""), i = t[2].split(",").map(function (e) { return e.trim().replace(/^"/, "").replace(/"$/, "") }), r = { name: n }, a = this.parseNodeAttr(i), o = this.getCurrentNode(); 0 === this.currentIndent ? this.allNodes.add(n, r) : n in o ? ("PoseNode" === n ? o.PoseNode.push(r) : void 0 !== o[n].id && (o[n] = {}, o[n][o[n].id] = o[n]), "" !== a.id && (o[n][a.id] = r)) : "number" == typeof a.id ? (o[n] = {}, o[n][a.id] = r) : "Properties70" !== n && (o[n] = "PoseNode" === n ? [r] : r), "number" == typeof a.id && (r.id = a.id), "" !== a.name && (r.attrName = a.name), "" !== a.type && (r.attrType = a.type), this.pushStack(r) }, parseNodeAttr: function (e) { var t = e[0]; "" !== e[0] && (t = parseInt(e[0]), isNaN(t) && (t = e[0])); var n = "", i = ""; return e.length > 1 && (n = e[1].replace(/^(\w+)::/, ""), i = e[2]), { id: t, name: n, type: i } }, parseNodeProperty: function (e, t, n) { var i = t[1].replace(/^"/, "").replace(/"$/, "").trim(), r = t[2].replace(/^"/, "").replace(/"$/, "").trim(); "Content" === i && "," === r && (r = n.replace(/"/g, "").replace(/,$/, "").trim()); var a = this.getCurrentNode(); if ("Properties70" !== a.name) { if ("C" === i) { var o = r.split(",").slice(1), s = parseInt(o[0]), c = parseInt(o[1]), l = r.split(",").slice(3); i = "connections", function (e, t) { for (var n = 0, i = e.length, r = t.length; n < r; n++, i++)e[i] = t[n] }(r = [s, c], l = l.map(function (e) { return e.trim().replace(/^"/, "") })), void 0 === a[i] && (a[i] = []) } "Node" === i && (a.id = r), i in a && Array.isArray(a[i]) ? a[i].push(r) : "a" !== i ? a[i] = r : a.a = r, this.setCurrentProp(a, i), "a" === i && "," !== r.slice(-1) && (a.a = f(r)) } else this.parseNodeSpecialProperty(e, i, r) }, parseNodePropertyContinued: function (e) { var t = this.getCurrentNode(); t.a += e, "," !== e.slice(-1) && (t.a = f(t.a)) }, parseNodeSpecialProperty: function (e, t, n) { var i = n.split('",').map(function (e) { return e.trim().replace(/^\"/, "").replace(/\s/, "_") }), r = i[0], a = i[1], o = i[2], s = i[3], c = i[4]; switch (a) { case "int": case "enum": case "bool": case "ULongLong": case "double": case "Number": case "FieldOfView": c = parseFloat(c); break; case "Color": case "ColorRGB": case "Vector3D": case "Lcl_Translation": case "Lcl_Rotation": case "Lcl_Scaling": c = f(c) }this.getPrevNode()[r] = { type: a, type2: o, flag: s, value: c }, this.setCurrentProp(this.getPrevNode(), r) } }, o.prototype = { constructor: o, parse: function (e) { var t = new s(e); t.skip(23); var n = t.getUint32(); console.log("THREE.FBXLoader: FBX binary version: " + n); for (var i = new c; !this.endOfContent(t);) { var r = this.parseNode(t, n); null !== r && i.add(r.name, r) } return i }, endOfContent: function (e) { return e.size() % 16 == 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size() }, parseNode: function (e, t) { var n = {}, i = t >= 7500 ? e.getUint64() : e.getUint32(), r = t >= 7500 ? e.getUint64() : e.getUint32(), a = (t >= 7500 ? e.getUint64() : e.getUint32(), e.getUint8()), o = e.getString(a); if (0 === i) return null; for (var s = [], c = 0; c < r; c++)s.push(this.parseProperty(e)); var l = s.length > 0 ? s[0] : "", h = s.length > 1 ? s[1] : "", u = s.length > 2 ? s[2] : ""; for (n.singleProperty = 1 === r && e.getOffset() === i; i > e.getOffset();) { var d = this.parseNode(e, t); null !== d && this.parseSubNode(o, n, d) } return n.propertyList = s, "number" == typeof l && (n.id = l), "" !== h && (n.attrName = h), "" !== u && (n.attrType = u), "" !== o && (n.name = o), n }, parseSubNode: function (e, t, n) { if (!0 === n.singleProperty) { var i = n.propertyList[0]; Array.isArray(i) ? (t[n.name] = n, n.a = i) : t[n.name] = i } else if ("Connections" === e && "C" === n.name) { var r = []; n.propertyList.forEach(function (e, t) { 0 !== t && r.push(e) }), void 0 === t.connections && (t.connections = []), t.connections.push(r) } else if ("Properties70" === n.name) { Object.keys(n).forEach(function (e) { t[e] = n[e] }) } else if ("Properties70" === e && "P" === n.name) { var a, o = n.propertyList[0], s = n.propertyList[1], c = n.propertyList[2], l = n.propertyList[3]; 0 === o.indexOf("Lcl ") && (o = o.replace("Lcl ", "Lcl_")), 0 === s.indexOf("Lcl ") && (s = s.replace("Lcl ", "Lcl_")), a = "Color" === s || "ColorRGB" === s || "Vector" === s || "Vector3D" === s || 0 === s.indexOf("Lcl_") ? [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : n.propertyList[4], t[o] = { type: s, type2: c, flag: l, value: a } } else void 0 === t[n.name] ? "number" == typeof n.id ? (t[n.name] = {}, t[n.name][n.id] = n) : t[n.name] = n : "PoseNode" === n.name ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]), t[n.name].push(n)) : void 0 === t[n.name][n.id] && (t[n.name][n.id] = n) }, parseProperty: function (e) { var t = e.getString(1); switch (t) { case "C": return e.getBoolean(); case "D": return e.getFloat64(); case "F": return e.getFloat32(); case "I": return e.getInt32(); case "L": return e.getInt64(); case "R": n = e.getUint32(); return e.getArrayBuffer(n); case "S": var n = e.getUint32(); return e.getString(n); case "Y": return e.getInt16(); case "b": case "c": case "d": case "f": case "i": case "l": var i = e.getUint32(), r = e.getUint32(), a = e.getUint32(); if (0 === r) switch (t) { case "b": case "c": return e.getBooleanArray(i); case "d": return e.getFloat64Array(i); case "f": return e.getFloat32Array(i); case "i": return e.getInt32Array(i); case "l": return e.getInt64Array(i) }"undefined" == typeof Zlib && console.error("THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js"); var o = new s(new Zlib.Inflate(new Uint8Array(e.getArrayBuffer(a))).decompress().buffer); switch (t) { case "b": case "c": return o.getBooleanArray(i); case "d": return o.getFloat64Array(i); case "f": return o.getFloat32Array(i); case "i": return o.getInt32Array(i); case "l": return o.getInt64Array(i) }default: throw new Error("THREE.FBXLoader: Unknown property type " + t) } } }, s.prototype = { constructor: s, getOffset: function () { return this.offset }, size: function () { return this.dv.buffer.byteLength }, skip: function (e) { this.offset += e }, getBoolean: function () { return 1 == (1 & this.getUint8()) }, getBooleanArray: function (e) { for (var t = [], n = 0; n < e; n++)t.push(this.getBoolean()); return t }, getUint8: function () { var e = this.dv.getUint8(this.offset); return this.offset += 1, e }, getInt16: function () { var e = this.dv.getInt16(this.offset, this.littleEndian); return this.offset += 2, e }, getInt32: function () { var e = this.dv.getInt32(this.offset, this.littleEndian); return this.offset += 4, e }, getInt32Array: function (e) { for (var t = [], n = 0; n < e; n++)t.push(this.getInt32()); return t }, getUint32: function () { var e = this.dv.getUint32(this.offset, this.littleEndian); return this.offset += 4, e }, getInt64: function () { var e, t; return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 2147483648 & t ? (t = 4294967295 & ~t, 4294967295 === (e = 4294967295 & ~e) && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(4294967296 * t + e)) : 4294967296 * t + e }, getInt64Array: function (e) { for (var t = [], n = 0; n < e; n++)t.push(this.getInt64()); return t }, getUint64: function () { var e, t; return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 4294967296 * t + e }, getFloat32: function () { var e = this.dv.getFloat32(this.offset, this.littleEndian); return this.offset += 4, e }, getFloat32Array: function (e) { for (var t = [], n = 0; n < e; n++)t.push(this.getFloat32()); return t }, getFloat64: function () { var e = this.dv.getFloat64(this.offset, this.littleEndian); return this.offset += 8, e }, getFloat64Array: function (e) { for (var t = [], n = 0; n < e; n++)t.push(this.getFloat64()); return t }, getArrayBuffer: function (e) { var t = this.dv.buffer.slice(this.offset, this.offset + e); return this.offset += e, t }, getString: function (e) { for (var t = [], n = 0; n < e; n++)t[n] = this.getUint8(); var i = t.indexOf(0); return i >= 0 && (t = t.slice(0, i)), THREE.LoaderUtils.decodeText(new Uint8Array(t)) } }, c.prototype = { constructor: c, add: function (e, t) { this[e] = t } }; var _ = [], b = new THREE.Matrix4, E = new THREE.Euler, w = new THREE.Vector3, M = new THREE.Vector3, T = new THREE.Matrix4; return e }() }, {}], 5: [function (e, t, n) { "use strict"; t.exports = Object.assign(function () { }, { FACE_1: 0, FACE_2: 1, FACE_3: 2, FACE_4: 3, L_SHOULDER_1: 4, R_SHOULDER_1: 5, L_SHOULDER_2: 6, R_SHOULDER_2: 7, SELECT: 8, START: 9, DPAD_UP: 12, DPAD_DOWN: 13, DPAD_LEFT: 14, DPAD_RIGHT: 15, VENDOR: 16 }) }, {}], 6: [function (e, t, n) { "use strict"; t.exports = function (e, t, n) { this.type = e, this.index = t, this.pressed = n.pressed, this.value = n.value } }, {}], 7: [function (e, t, n) { "use strict"; function i(e) { var t = document.getElementById(e), n = t.parentNode; try { n && n.removeChild(t) } catch (e) { } } function r(e, t, n) { return new n(function (n, r) { var a = t.timeout || 5e3, o = "script_" + Date.now() + "_" + Math.ceil(1e5 * Math.random()), s = function (e, t) { var n = document.createElement("script"); return n.type = "text/javascript", n.async = !0, n.id = t, n.src = e, n }(e, o), c = setTimeout(function () { r(new Error("Script request to " + e + " timed out")), i(o) }, a), l = function (e) { clearTimeout(e) }; s.addEventListener("load", function (e) { n({ ok: !0 }), l(c), i(o) }), s.addEventListener("error", function (t) { r(new Error("Script request to " + e + " failed " + t)), l(c), i(o) }), function (e) { var t = document.getElementsByTagName("script")[0]; t.parentNode.insertBefore(e, t) }(s) }) } t.exports = function (e) { return e = e || {}, function (t, n) { return n = n || {}, r(t, n, e.Promise || Promise) } } }, {}], 8: [function (e, t, n) { "use strict"; !function (e) { function t(e, t) { return -1 !== String(e).indexOf(t) } function n(e, t, n) { u !== t && h !== t && l !== t || Object.keys(n).forEach(function (t) { e[t] = n[t] }) } function i(e) { var t = "keyCode" in e ? e.keyCode : "which" in e ? e.which : 0, n = function () { if (y || "keyLocation" in e) { var n = y ? e.location : e.keyLocation; if (n && t in f[n]) return f[n][t] } return "keyIdentifier" in e && e.keyIdentifier in p ? p[e.keyIdentifier] : t in d ? d[t] : null }(); if (!n) return null; var i = function () { var t = m[n.code]; return t ? e.shiftKey && "shiftKey" in t ? t.shiftKey : t.key : n.code }(); return { code: n.code, key: i, location: n.location, keyCap: n.keyCap } } var r = "KeyboardEvent" in e; r || (e.KeyboardEvent = function () { throw TypeError("Illegal constructor") }), "DOM_KEY_LOCATION_STANDARD" in e.KeyboardEvent || (e.KeyboardEvent.DOM_KEY_LOCATION_STANDARD = 0), "DOM_KEY_LOCATION_LEFT" in e.KeyboardEvent || (e.KeyboardEvent.DOM_KEY_LOCATION_LEFT = 1), "DOM_KEY_LOCATION_RIGHT" in e.KeyboardEvent || (e.KeyboardEvent.DOM_KEY_LOCATION_RIGHT = 2), "DOM_KEY_LOCATION_NUMPAD" in e.KeyboardEvent || (e.KeyboardEvent.DOM_KEY_LOCATION_NUMPAD = 3); var a = window.KeyboardEvent.DOM_KEY_LOCATION_STANDARD, o = window.KeyboardEvent.DOM_KEY_LOCATION_LEFT, s = window.KeyboardEvent.DOM_KEY_LOCATION_RIGHT, c = window.KeyboardEvent.DOM_KEY_LOCATION_NUMPAD, l = t(navigator.platform, "Win") ? "win" : t(navigator.platform, "Mac") ? "mac" : t(navigator.platform, "CrOS") ? "cros" : t(navigator.platform, "Linux") ? "linux" : t(navigator.userAgent, "iPad") || t(navigator.platform, "iPod") || t(navigator.platform, "iPhone") ? "ios" : "", h = t(navigator.userAgent, "Chrome/") ? "chrome" : t(navigator.vendor, "Apple") ? "safari" : t(navigator.userAgent, "MSIE") ? "ie" : t(navigator.userAgent, "Gecko/") ? "moz" : t(navigator.userAgent, "Opera/") ? "opera" : "", u = h + "-" + l, d = { 3: { code: "Cancel" }, 6: { code: "Help" }, 8: { code: "Backspace" }, 9: { code: "Tab" }, 12: { code: "Clear" }, 13: { code: "Enter" }, 16: { code: "Shift" }, 17: { code: "Control" }, 18: { code: "Alt" }, 19: { code: "Pause" }, 20: { code: "CapsLock" }, 21: { code: "KanaMode" }, 22: { code: "HangulMode" }, 23: { code: "JunjaMode" }, 24: { code: "FinalMode" }, 25: { code: "KanjiMode" }, 27: { code: "Escape" }, 28: { code: "Convert" }, 29: { code: "NonConvert" }, 30: { code: "Accept" }, 31: { code: "ModeChange" }, 32: { code: "Space" }, 33: { code: "PageUp" }, 34: { code: "PageDown" }, 35: { code: "End" }, 36: { code: "Home" }, 37: { code: "ArrowLeft" }, 38: { code: "ArrowUp" }, 39: { code: "ArrowRight" }, 40: { code: "ArrowDown" }, 41: { code: "Select" }, 42: { code: "Print" }, 43: { code: "Execute" }, 44: { code: "PrintScreen" }, 45: { code: "Insert" }, 46: { code: "Delete" }, 47: { code: "Help" }, 48: { code: "Digit0", keyCap: "0" }, 49: { code: "Digit1", keyCap: "1" }, 50: { code: "Digit2", keyCap: "2" }, 51: { code: "Digit3", keyCap: "3" }, 52: { code: "Digit4", keyCap: "4" }, 53: { code: "Digit5", keyCap: "5" }, 54: { code: "Digit6", keyCap: "6" }, 55: { code: "Digit7", keyCap: "7" }, 56: { code: "Digit8", keyCap: "8" }, 57: { code: "Digit9", keyCap: "9" }, 65: { code: "KeyA", keyCap: "a" }, 66: { code: "KeyB", keyCap: "b" }, 67: { code: "KeyC", keyCap: "c" }, 68: { code: "KeyD", keyCap: "d" }, 69: { code: "KeyE", keyCap: "e" }, 70: { code: "KeyF", keyCap: "f" }, 71: { code: "KeyG", keyCap: "g" }, 72: { code: "KeyH", keyCap: "h" }, 73: { code: "KeyI", keyCap: "i" }, 74: { code: "KeyJ", keyCap: "j" }, 75: { code: "KeyK", keyCap: "k" }, 76: { code: "KeyL", keyCap: "l" }, 77: { code: "KeyM", keyCap: "m" }, 78: { code: "KeyN", keyCap: "n" }, 79: { code: "KeyO", keyCap: "o" }, 80: { code: "KeyP", keyCap: "p" }, 81: { code: "KeyQ", keyCap: "q" }, 82: { code: "KeyR", keyCap: "r" }, 83: { code: "KeyS", keyCap: "s" }, 84: { code: "KeyT", keyCap: "t" }, 85: { code: "KeyU", keyCap: "u" }, 86: { code: "KeyV", keyCap: "v" }, 87: { code: "KeyW", keyCap: "w" }, 88: { code: "KeyX", keyCap: "x" }, 89: { code: "KeyY", keyCap: "y" }, 90: { code: "KeyZ", keyCap: "z" }, 91: { code: "OSLeft", location: o }, 92: { code: "OSRight", location: s }, 93: { code: "ContextMenu" }, 95: { code: "Standby" }, 96: { code: "Numpad0", keyCap: "0", location: c }, 97: { code: "Numpad1", keyCap: "1", location: c }, 98: { code: "Numpad2", keyCap: "2", location: c }, 99: { code: "Numpad3", keyCap: "3", location: c }, 100: { code: "Numpad4", keyCap: "4", location: c }, 101: { code: "Numpad5", keyCap: "5", location: c }, 102: { code: "Numpad6", keyCap: "6", location: c }, 103: { code: "Numpad7", keyCap: "7", location: c }, 104: { code: "Numpad8", keyCap: "8", location: c }, 105: { code: "Numpad9", keyCap: "9", location: c }, 106: { code: "NumpadMultiply", keyCap: "*", location: c }, 107: { code: "NumpadAdd", keyCap: "+", location: c }, 108: { code: "NumpadComma", keyCap: ",", location: c }, 109: { code: "NumpadSubtract", keyCap: "-", location: c }, 110: { code: "NumpadDecimal", keyCap: ".", location: c }, 111: { code: "NumpadDivide", keyCap: "/", location: c }, 112: { code: "F1" }, 113: { code: "F2" }, 114: { code: "F3" }, 115: { code: "F4" }, 116: { code: "F5" }, 117: { code: "F6" }, 118: { code: "F7" }, 119: { code: "F8" }, 120: { code: "F9" }, 121: { code: "F10" }, 122: { code: "F11" }, 123: { code: "F12" }, 124: { code: "F13" }, 125: { code: "F14" }, 126: { code: "F15" }, 127: { code: "F16" }, 128: { code: "F17" }, 129: { code: "F18" }, 130: { code: "F19" }, 131: { code: "F20" }, 132: { code: "F21" }, 133: { code: "F22" }, 134: { code: "F23" }, 135: { code: "F24" }, 144: { code: "NumLock", location: c }, 145: { code: "ScrollLock" }, 160: { code: "ShiftLeft", location: o }, 161: { code: "ShiftRight", location: s }, 162: { code: "ControlLeft", location: o }, 163: { code: "ControlRight", location: s }, 164: { code: "AltLeft", location: o }, 165: { code: "AltRight", location: s }, 166: { code: "BrowserBack" }, 167: { code: "BrowserForward" }, 168: { code: "BrowserRefresh" }, 169: { code: "BrowserStop" }, 170: { code: "BrowserSearch" }, 171: { code: "BrowserFavorites" }, 172: { code: "BrowserHome" }, 173: { code: "VolumeMute" }, 174: { code: "VolumeDown" }, 175: { code: "VolumeUp" }, 176: { code: "MediaTrackNext" }, 177: { code: "MediaTrackPrevious" }, 178: { code: "MediaStop" }, 179: { code: "MediaPlayPause" }, 180: { code: "LaunchMail" }, 181: { code: "MediaSelect" }, 182: { code: "LaunchApp1" }, 183: { code: "LaunchApp2" }, 186: { code: "Semicolon", keyCap: ";" }, 187: { code: "Equal", keyCap: "=" }, 188: { code: "Comma", keyCap: "," }, 189: { code: "Minus", keyCap: "-" }, 190: { code: "Period", keyCap: "." }, 191: { code: "Slash", keyCap: "/" }, 192: { code: "Backquote", keyCap: "`" }, 219: { code: "BracketLeft", keyCap: "[" }, 220: { code: "Backslash", keyCap: "\\" }, 221: { code: "BracketRight", keyCap: "]" }, 222: { code: "Quote", keyCap: "'" }, 226: { code: "IntlBackslash", keyCap: "\\" }, 229: { code: "Process" }, 246: { code: "Attn" }, 247: { code: "CrSel" }, 248: { code: "ExSel" }, 249: { code: "EraseEof" }, 250: { code: "Play" }, 251: { code: "ZoomToggle" }, 254: { code: "Clear" } }; n(d, "moz", { 59: { code: "Semicolon", keyCap: ";" }, 61: { code: "Equal", keyCap: "=" }, 107: { code: "Equal", keyCap: "=" }, 109: { code: "Minus", keyCap: "-" }, 187: { code: "NumpadAdd", keyCap: "+", location: c }, 189: { code: "NumpadSubtract", keyCap: "-", location: c } }), n(d, "moz-mac", { 12: { code: "NumLock", location: c }, 173: { code: "Minus", keyCap: "-" } }), n(d, "moz-win", { 173: { code: "Minus", keyCap: "-" } }), n(d, "chrome-mac", { 93: { code: "OSRight", location: s } }), n(d, "safari", { 3: { code: "Enter" }, 25: { code: "Tab" } }), n(d, "ios", { 10: { code: "Enter", location: a } }), n(d, "safari-mac", { 91: { code: "OSLeft", location: o }, 93: { code: "OSRight", location: s }, 229: { code: "KeyQ", keyCap: "Q" } }); var p = {}; "cros" === l && (p["U+00A0"] = { code: "ShiftLeft", location: o }, p["U+00A1"] = { code: "ShiftRight", location: s }, p["U+00A2"] = { code: "ControlLeft", location: o }, p["U+00A3"] = { code: "ControlRight", location: s }, p["U+00A4"] = { code: "AltLeft", location: o }, p["U+00A5"] = { code: "AltRight", location: s }), "chrome-mac" === u && (p["U+0010"] = { code: "ContextMenu" }), "safari-mac" === u && (p["U+0010"] = { code: "ContextMenu" }), "ios" === l && (p["U+0010"] = { code: "Function" }, p["U+001C"] = { code: "ArrowLeft" }, p["U+001D"] = { code: "ArrowRight" }, p["U+001E"] = { code: "ArrowUp" }, p["U+001F"] = { code: "ArrowDown" }, p["U+0001"] = { code: "Home" }, p["U+0004"] = { code: "End" }, p["U+000B"] = { code: "PageUp" }, p["U+000C"] = { code: "PageDown" }); var f = []; f[o] = { 16: { code: "ShiftLeft", location: o }, 17: { code: "ControlLeft", location: o }, 18: { code: "AltLeft", location: o } }, f[s] = { 16: { code: "ShiftRight", location: s }, 17: { code: "ControlRight", location: s }, 18: { code: "AltRight", location: s } }, f[c] = { 13: { code: "NumpadEnter", location: c } }, n(f[c], "moz", { 109: { code: "NumpadSubtract", location: c }, 107: { code: "NumpadAdd", location: c } }), n(f[o], "moz-mac", { 224: { code: "OSLeft", location: o } }), n(f[s], "moz-mac", { 224: { code: "OSRight", location: s } }), n(f[s], "moz-win", { 91: { code: "OSRight", location: s } }), n(f[s], "mac", { 93: { code: "OSRight", location: s } }), n(f[c], "chrome-mac", { 12: { code: "NumLock", location: c } }), n(f[c], "safari-mac", { 12: { code: "NumLock", location: c }, 187: { code: "NumpadAdd", location: c }, 189: { code: "NumpadSubtract", location: c }, 190: { code: "NumpadDecimal", location: c }, 191: { code: "NumpadDivide", location: c } }); var m = { ShiftLeft: { key: "Shift" }, ShiftRight: { key: "Shift" }, ControlLeft: { key: "Control" }, ControlRight: { key: "Control" }, AltLeft: { key: "Alt" }, AltRight: { key: "Alt" }, OSLeft: { key: "OS" }, OSRight: { key: "OS" }, NumpadEnter: { key: "Enter" }, Space: { key: " " }, Digit0: { key: "0", shiftKey: ")" }, Digit1: { key: "1", shiftKey: "!" }, Digit2: { key: "2", shiftKey: "@" }, Digit3: { key: "3", shiftKey: "#" }, Digit4: { key: "4", shiftKey: "$" }, Digit5: { key: "5", shiftKey: "%" }, Digit6: { key: "6", shiftKey: "^" }, Digit7: { key: "7", shiftKey: "&" }, Digit8: { key: "8", shiftKey: "*" }, Digit9: { key: "9", shiftKey: "(" }, KeyA: { key: "a", shiftKey: "A" }, KeyB: { key: "b", shiftKey: "B" }, KeyC: { key: "c", shiftKey: "C" }, KeyD: { key: "d", shiftKey: "D" }, KeyE: { key: "e", shiftKey: "E" }, KeyF: { key: "f", shiftKey: "F" }, KeyG: { key: "g", shiftKey: "G" }, KeyH: { key: "h", shiftKey: "H" }, KeyI: { key: "i", shiftKey: "I" }, KeyJ: { key: "j", shiftKey: "J" }, KeyK: { key: "k", shiftKey: "K" }, KeyL: { key: "l", shiftKey: "L" }, KeyM: { key: "m", shiftKey: "M" }, KeyN: { key: "n", shiftKey: "N" }, KeyO: { key: "o", shiftKey: "O" }, KeyP: { key: "p", shiftKey: "P" }, KeyQ: { key: "q", shiftKey: "Q" }, KeyR: { key: "r", shiftKey: "R" }, KeyS: { key: "s", shiftKey: "S" }, KeyT: { key: "t", shiftKey: "T" }, KeyU: { key: "u", shiftKey: "U" }, KeyV: { key: "v", shiftKey: "V" }, KeyW: { key: "w", shiftKey: "W" }, KeyX: { key: "x", shiftKey: "X" }, KeyY: { key: "y", shiftKey: "Y" }, KeyZ: { key: "z", shiftKey: "Z" }, Numpad0: { key: "0" }, Numpad1: { key: "1" }, Numpad2: { key: "2" }, Numpad3: { key: "3" }, Numpad4: { key: "4" }, Numpad5: { key: "5" }, Numpad6: { key: "6" }, Numpad7: { key: "7" }, Numpad8: { key: "8" }, Numpad9: { key: "9" }, NumpadMultiply: { key: "*" }, NumpadAdd: { key: "+" }, NumpadComma: { key: "," }, NumpadSubtract: { key: "-" }, NumpadDecimal: { key: "." }, NumpadDivide: { key: "/" }, Semicolon: { key: ";", shiftKey: ":" }, Equal: { key: "=", shiftKey: "+" }, Comma: { key: ",", shiftKey: "<" }, Minus: { key: "-", shiftKey: "_" }, Period: { key: ".", shiftKey: ">" }, Slash: { key: "/", shiftKey: "?" }, Backquote: { key: "`", shiftKey: "~" }, BracketLeft: { key: "[", shiftKey: "{" }, Backslash: { key: "\\", shiftKey: "|" }, BracketRight: { key: "]", shiftKey: "}" }, Quote: { key: "'", shiftKey: '"' }, IntlBackslash: { key: "\\", shiftKey: "|" } }; n(m, "mac", { OSLeft: { key: "Meta" }, OSRight: { key: "Meta" } }); var g = { Esc: "Escape", Nonconvert: "NonConvert", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Menu: "ContextMenu", MediaNextTrack: "MediaTrackNext", MediaPreviousTrack: "MediaTrackPrevious", SelectMedia: "MediaSelect", HalfWidth: "Hankaku", FullWidth: "Zenkaku", RomanCharacters: "Romaji", Crsel: "CrSel", Exsel: "ExSel", Zoom: "ZoomToggle" }, v = function (e, t) { var n = {}; return Object.keys(e).forEach(function (i) { var r = e[i]; t in r && (n[r[t]] = r) }), n }(d, "code"); try { var y = r && "location" in new KeyboardEvent("") } catch (e) { } "KeyboardEvent" in e && "defineProperty" in Object && function () { function e(e, t, n) { t in e || Object.defineProperty(e, t, n) } if (e(KeyboardEvent.prototype, "code", { get: function () { var e = i(this); return e ? e.code : "" } }), "key" in KeyboardEvent.prototype) { var t = Object.getOwnPropertyDescriptor(KeyboardEvent.prototype, "key"); Object.defineProperty(KeyboardEvent.prototype, "key", { get: function () { var e = t.get.call(this); return g.hasOwnProperty(e) ? g[e] : e } }) } e(KeyboardEvent.prototype, "key", { get: function () { var e = i(this); return e && "key" in e ? e.key : "Unidentified" } }), e(KeyboardEvent.prototype, "location", { get: function () { var e = i(this); return e && "location" in e ? e.location : a } }), e(KeyboardEvent.prototype, "locale", { get: function () { return "" } }) }(), "queryKeyCap" in e.KeyboardEvent || (e.KeyboardEvent.queryKeyCap = function (e, t) { if (e = String(e), !v.hasOwnProperty(e)) return "Undefined"; if (t && "en-us" !== String(t).toLowerCase()) throw Error("Unsupported locale"); var n = v[e]; return n.keyCap || n.code || "Undefined" }), e.identifyKey = function (e) { if (!("code" in e)) { var t = i(e); e.code = t ? t.code : "", e.key = t && "key" in t ? t.key : "Unidentified", e.location = "location" in e ? e.location : "keyLocation" in e ? e.keyLocation : t && "location" in t ? t.location : a, e.locale = "" } } }(window) }, {}], 9: [function (e, t, n) { var i = e("three"); class r { static roundNumber(e, t) { const n = Math.pow(10, t); return Math.round(e * n) / n } static sample(e) { return e[Math.floor(Math.random() * e.length)] } static distanceToSquared(e, t) { var n = e.x - t.x, i = e.y - t.y, r = e.z - t.z; return n * n + i * i + r * r } static isPointInPoly(e, t) { for (var n = !1, i = -1, r = e.length, a = r - 1; ++i < r; a = i)(e[i].z <= t.z && t.z < e[a].z || e[a].z <= t.z && t.z < e[i].z) && t.x < (e[a].x - e[i].x) * (t.z - e[i].z) / (e[a].z - e[i].z) + e[i].x && (n = !n); return n } static isVectorInPolygon(e, t, n) { var i = 1e5, r = -1e5, a = []; return t.vertexIds.forEach(e => { i = Math.min(n[e].y, i), r = Math.max(n[e].y, r), a.push(n[e]) }), !!(e.y < r + .5 && e.y > i - .5 && this.isPointInPoly(a, e)) } static triarea2(e, t, n) { return (n.x - e.x) * (t.z - e.z) - (t.x - e.x) * (n.z - e.z) } static vequal(e, t) { return this.distanceToSquared(e, t) < 1e-5 } static mergeVertices(e, t = 1e-4) { t = Math.max(t, Number.EPSILON); for (var n = {}, r = e.getIndex(), a = e.getAttribute("position"), o = r ? r.count : a.count, s = 0, c = [], l = [], h = Math.log10(1 / t), u = Math.pow(10, h), d = 0; d < o; d++) { var p = r ? r.getX(d) : d, f = ""; f += ~~(a.getX(p) * u) + ",", f += ~~(a.getY(p) * u) + ",", (f += ~~(a.getZ(p) * u) + ",") in n ? c.push(n[f]) : (l.push(a.getX(p)), l.push(a.getY(p)), l.push(a.getZ(p)), n[f] = s, c.push(s), s++) } const m = new i.BufferAttribute(new Float32Array(l), a.itemSize, a.normalized), g = new i.BufferGeometry; return g.setAttribute("position", m), g.setIndex(c), g } } class a { constructor(e) { this.content = [], this.scoreFunction = e } push(e) { this.content.push(e), this.sinkDown(this.content.length - 1) } pop() { const e = this.content[0], t = this.content.pop(); return this.content.length > 0 && (this.content[0] = t, this.bubbleUp(0)), e } remove(e) { const t = this.content.indexOf(e), n = this.content.pop(); t !== this.content.length - 1 && (this.content[t] = n, this.scoreFunction(n) < this.scoreFunction(e) ? this.sinkDown(t) : this.bubbleUp(t)) } size() { return this.content.length } rescoreElement(e) { this.sinkDown(this.content.indexOf(e)) } sinkDown(e) { const t = this.content[e]; for (; e > 0;) { const n = (e + 1 >> 1) - 1, i = this.content[n]; if (!(this.scoreFunction(t) < this.scoreFunction(i))) break; this.content[n] = t, this.content[e] = i, e = n } } bubbleUp(e) { const t = this.content.length, n = this.content[e], i = this.scoreFunction(n); for (; ;) { const r = e + 1 << 1, a = r - 1; let o, s = null; if (a < t && (o = this.scoreFunction(this.content[a])) < i && (s = a), r < t && this.scoreFunction(this.content[r]) < (null === s ? i : o) && (s = r), null === s) break; this.content[e] = this.content[s], this.content[s] = n, e = s } } } class o { constructor() { this.portals = [] } push(e, t) { void 0 === t && (t = e), this.portals.push({ left: e, right: t }) } stringPull() { const e = this.portals, t = []; let n, i, a, o = 0, s = 0, c = 0; n = e[0].left, i = e[0].left, a = e[0].right, t.push(n); for (let l = 1; l < e.length; l++) { const h = e[l].left, u = e[l].right; if (r.triarea2(n, a, u) <= 0) { if (!(r.vequal(n, a) || r.triarea2(n, i, u) > 0)) { t.push(i), i = n = i, a = n, s = o = s, c = o, l = o; continue } a = u, c = l } if (r.triarea2(n, i, h) >= 0) { if (!(r.vequal(n, i) || r.triarea2(n, a, h) < 0)) { t.push(a), i = n = a, a = n, s = o = c, c = o, l = o; continue } i = h, s = l } } return 0 !== t.length && r.vequal(t[t.length - 1], e[e.length - 1].left) || t.push(e[e.length - 1].left), this.path = t, t } } class s { constructor() { this.zones = {} } static createZone(e, t = 1e-4) { return class { static buildZone(e, t) { const n = this._buildNavigationMesh(e, t), a = {}; n.vertices.forEach(e => { e.x = r.roundNumber(e.x, 2), e.y = r.roundNumber(e.y, 2), e.z = r.roundNumber(e.z, 2) }), a.vertices = n.vertices; const o = this._buildPolygonGroups(n); return a.groups = new Array(o.length), o.forEach((e, t) => { const n = new Map; e.forEach((e, t) => { n.set(e, t) }); const o = new Array(e.length); e.forEach((e, t) => { const s = []; e.neighbours.forEach(e => s.push(n.get(e))); const c = []; e.neighbours.forEach(t => c.push(this._getSharedVerticesInOrder(e, t))); const l = new i.Vector3(0, 0, 0); l.add(a.vertices[e.vertexIds[0]]), l.add(a.vertices[e.vertexIds[1]]), l.add(a.vertices[e.vertexIds[2]]), l.divideScalar(3), l.x = r.roundNumber(l.x, 2), l.y = r.roundNumber(l.y, 2), l.z = r.roundNumber(l.z, 2), o[t] = { id: t, neighbours: s, vertexIds: e.vertexIds, centroid: l, portals: c } }), a.groups[t] = o }), a } static _buildNavigationMesh(e, t) { return e = r.mergeVertices(e, t), this._buildPolygonsFromGeometry(e) } static _spreadGroupId(e) { let t = new Set([e]); for (; t.size > 0;) { const n = t; t = new Set, n.forEach(n => { n.group = e.group, n.neighbours.forEach(e => { void 0 === e.group && t.add(e) }) }) } } static _buildPolygonGroups(e) { const t = []; return e.polygons.forEach(e => { void 0 !== e.group ? t[e.group].push(e) : (e.group = t.length, this._spreadGroupId(e), t.push([e])) }), t } static _buildPolygonNeighbours(e, t) { const n = new Set, i = t[e.vertexIds[1]], r = t[e.vertexIds[2]]; return t[e.vertexIds[0]].forEach(t => { t !== e && (i.includes(t) || r.includes(t)) && n.add(t) }), i.forEach(t => { t !== e && r.includes(t) && n.add(t) }), n } static _buildPolygonsFromGeometry(e) { const t = [], n = [], r = e.attributes.position, a = e.index, o = []; for (let e = 0; e < r.count; e++)n.push((new i.Vector3).fromBufferAttribute(r, e)), o[e] = []; for (let n = 0; n < e.index.count; n += 3) { const e = a.getX(n), i = a.getX(n + 1), r = a.getX(n + 2), s = { vertexIds: [e, i, r], neighbours: null }; t.push(s), o[e].push(s), o[i].push(s), o[r].push(s) } return t.forEach(e => { e.neighbours = this._buildPolygonNeighbours(e, o) }), { polygons: t, vertices: n } } static _getSharedVerticesInOrder(e, t) { const n = e.vertexIds, i = n[0], r = n[1], a = n[2], o = t.vertexIds, s = o.includes(i), c = o.includes(r), l = o.includes(a); return s && c && l ? Array.from(n) : s && c ? [i, r] : c && l ? [r, a] : s && l ? [a, i] : (console.warn("Error processing navigation mesh neighbors; neighbors with <2 shared vertices found."), []) } }.buildZone(e, t) } setZoneData(e, t) { this.zones[e] = t } getRandomNode(e, t, n, a) { if (!this.zones[e]) return new i.Vector3; n = n || null, a = a || 0; const o = []; return this.zones[e].groups[t].forEach(e => { n && a ? r.distanceToSquared(n, e.centroid) < a * a && o.push(e.centroid) : o.push(e.centroid) }), r.sample(o) || new i.Vector3 } getClosestNode(e, t, n, i = !1) { const a = this.zones[t].vertices; let o = null, s = 1 / 0; return this.zones[t].groups[n].forEach(t => { const n = r.distanceToSquared(t.centroid, e); n < s && (!i || r.isVectorInPolygon(e, t, a)) && (o = t, s = n) }), o } findPath(e, t, n, s) { const c = this.zones[n].groups[s], l = this.zones[n].vertices, h = this.getClosestNode(e, n, s, !0), u = this.getClosestNode(t, n, s, !0); if (!h || !u) return null; const d = class { static init(e) { for (let t = 0; t < e.length; t++) { const n = e[t]; n.f = 0, n.g = 0, n.h = 0, n.cost = 1, n.visited = !1, n.closed = !1, n.parent = null } } static cleanUp(e) { for (let t = 0; t < e.length; t++) { const n = e[t]; delete n.f, delete n.g, delete n.h, delete n.cost, delete n.visited, delete n.closed, delete n.parent } } static heap() { return new a(function (e) { return e.f }) } static search(e, t, n) { this.init(e); const i = this.heap(); for (i.push(t); i.size() > 0;) { const t = i.pop(); if (t === n) { let e = t; const n = []; for (; e.parent;)n.push(e), e = e.parent; return this.cleanUp(n), n.reverse() } t.closed = !0; const r = this.neighbours(e, t); for (let e = 0, a = r.length; e < a; e++) { const a = r[e]; if (a.closed) continue; const o = t.g + a.cost, s = a.visited; if (!s || o < a.g) { if (a.visited = !0, a.parent = t, !a.centroid || !n.centroid) throw new Error("Unexpected state"); a.h = a.h || this.heuristic(a.centroid, n.centroid), a.g = o, a.f = a.g + a.h, s ? i.rescoreElement(a) : i.push(a) } } } return [] } static heuristic(e, t) { return r.distanceToSquared(e, t) } static neighbours(e, t) { const n = []; for (let i = 0; i < t.neighbours.length; i++)n.push(e[t.neighbours[i]]); return n } }.search(c, h, u), p = function (e, t) { for (var n = 0; n < e.neighbours.length; n++)if (e.neighbours[n] === t.id) return e.portals[n] }, f = new o; f.push(e); for (let e = 0; e < d.length; e++) { const t = d[e], n = d[e + 1]; if (n) { const e = p(t, n); f.push(l[e[0]], l[e[1]]) } } f.push(t), f.stringPull(); const m = f.path.map(e => new i.Vector3(e.x, e.y, e.z)); return m.shift(), m } } s.prototype.getGroup = function () { const e = new i.Plane; return function (t, n, i = !1) { if (!this.zones[t]) return null; let a = null, o = Math.pow(50, 2); const s = this.zones[t]; for (let t = 0; t < s.groups.length; t++) { const c = s.groups[t]; for (const l of c) { if (i && (e.setFromCoplanarPoints(s.vertices[l.vertexIds[0]], s.vertices[l.vertexIds[1]], s.vertices[l.vertexIds[2]]), Math.abs(e.distanceToPoint(n)) < .01) && r.isPointInPoly([s.vertices[l.vertexIds[0]], s.vertices[l.vertexIds[1]], s.vertices[l.vertexIds[2]]], n)) return t; const c = r.distanceToSquared(l.centroid, n); c < o && (a = t, o = c) } } return a } }(), s.prototype.clampStep = function () { const e = new i.Vector3, t = new i.Plane, n = new i.Triangle, r = new i.Vector3; let a, o, s = new i.Vector3; return function (i, c, l, h, u, d) { const p = this.zones[h].vertices, f = this.zones[h].groups[u], m = [l], g = {}; g[l.id] = 0, a = void 0, s.set(0, 0, 0), o = 1 / 0, t.setFromCoplanarPoints(p[l.vertexIds[0]], p[l.vertexIds[1]], p[l.vertexIds[2]]), t.projectPoint(c, e), r.copy(e); for (let t = m.pop(); t; t = m.pop()) { n.set(p[t.vertexIds[0]], p[t.vertexIds[1]], p[t.vertexIds[2]]), n.closestPointToPoint(r, e), e.distanceToSquared(r) < o && (a = t, s.copy(e), o = e.distanceToSquared(r)); const i = g[t.id]; if (!(i > 2)) for (let e = 0; e < t.neighbours.length; e++) { const n = f[t.neighbours[e]]; n.id in g || (m.push(n), g[n.id] = i + 1) } } return d.copy(s), a } }(); const c = { PLAYER: new i.Color(15631215).convertSRGBToLinear().getHex(), TARGET: new i.Color(14469912).convertSRGBToLinear().getHex(), PATH: new i.Color(41903).convertSRGBToLinear().getHex(), WAYPOINT: new i.Color(41903).convertSRGBToLinear().getHex(), CLAMPED_STEP: new i.Color(14472114).convertSRGBToLinear().getHex(), CLOSEST_NODE: new i.Color(4417387).convertSRGBToLinear().getHex() }; n.Pathfinding = s, n.PathfindingHelper = class extends i.Object3D { constructor() { super(), this._playerMarker = new i.Mesh(new i.SphereBufferGeometry(.25, 32, 32), new i.MeshBasicMaterial({ color: c.PLAYER })), this._targetMarker = new i.Mesh(new i.BoxBufferGeometry(.3, .3, .3), new i.MeshBasicMaterial({ color: c.TARGET })), this._nodeMarker = new i.Mesh(new i.BoxBufferGeometry(.1, .8, .1), new i.MeshBasicMaterial({ color: c.CLOSEST_NODE })), this._stepMarker = new i.Mesh(new i.BoxBufferGeometry(.1, 1, .1), new i.MeshBasicMaterial({ color: c.CLAMPED_STEP })), this._pathMarker = new i.Object3D, this._pathLineMaterial = new i.LineBasicMaterial({ color: c.PATH, linewidth: 2 }), this._pathPointMaterial = new i.MeshBasicMaterial({ color: c.WAYPOINT }), this._pathPointGeometry = new i.SphereBufferGeometry(.08), this._markers = [this._playerMarker, this._targetMarker, this._nodeMarker, this._stepMarker, this._pathMarker], this._markers.forEach(e => { e.visible = !1, this.add(e) }) } setPath(e) { for (; this._pathMarker.children.length;)this._pathMarker.children[0].visible = !1, this._pathMarker.remove(this._pathMarker.children[0]); e = [this._playerMarker.position].concat(e); const t = new i.BufferGeometry; t.setAttribute("position", new i.BufferAttribute(new Float32Array(3 * e.length), 3)); for (let n = 0; n < e.length; n++)t.attributes.position.setXYZ(n, e[n].x, e[n].y + .2, e[n].z); this._pathMarker.add(new i.Line(t, this._pathLineMaterial)); for (let t = 0; t < e.length - 1; t++) { const n = new i.Mesh(this._pathPointGeometry, this._pathPointMaterial); n.position.copy(e[t]), n.position.y += .2, this._pathMarker.add(n) } return this._pathMarker.visible = !0, this } setPlayerPosition(e) { return this._playerMarker.position.copy(e), this._playerMarker.visible = !0, this } setTargetPosition(e) { return this._targetMarker.position.copy(e), this._targetMarker.visible = !0, this } setNodePosition(e) { return this._nodeMarker.position.copy(e), this._nodeMarker.visible = !0, this } setStepPosition(e) { return this._stepMarker.position.copy(e), this._stepMarker.visible = !0, this } reset() { for (; this._pathMarker.children.length;)this._pathMarker.children[0].visible = !1, this._pathMarker.remove(this._pathMarker.children[0]); return this._markers.forEach(e => { e.visible = !1 }), this } } }, { three: 10 }], 10: [function (e, t, n) { !function (e, i) { "object" == typeof n && void 0 !== t ? i(n) : "function" == typeof define && define.amd ? define(["exports"], i) : (e = "undefined" != typeof globalThis ? globalThis : e || self, i(e.THREE = {})) }(this, function (e) { "use strict"; function t() { } function n(e) { return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? oa.getDataURL(e) : e.data ? { data: Array.prototype.slice.call(e.data), width: e.width, height: e.height, type: e.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } function i(e, t, n, i, r) { for (let a = 0, o = e.length - 3; a <= o; a += 3) { La.fromArray(e, a); const o = r.x * Math.abs(La.x) + r.y * Math.abs(La.y) + r.z * Math.abs(La.z), s = t.dot(La), c = n.dot(La), l = i.dot(La); if (Math.max(-Math.max(s, c, l), Math.min(s, c, l)) > o) return !1 } return !0 } function r() { Object.defineProperty(this, "id", { value: to++ }), this.uuid = na.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = r.DefaultUp.clone(); const e = new pa, t = new $a, n = new da, i = new pa(1, 1, 1); t._onChange(function () { n.setFromEuler(t, !1) }), n._onChange(function () { t.setFromQuaternion(n, void 0, !1) }), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: i }, modelViewMatrix: { value: new Va }, normalMatrix: { value: new ra } }), this.matrix = new Va, this.matrixWorld = new Va, this.matrixAutoUpdate = r.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new eo, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } function a() { Object.defineProperty(this, "id", { value: Co++ }), this.uuid = na.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = An, this.side = wn, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = Gn, this.blendDst = zn, this.blendEquation = Nn, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Jn, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Zr, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Kr, this.stencilZFail = Kr, this.stencilZPass = Kr, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0 } function o(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e } function s(e) { return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4) } function c(e) { return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055 } function l(e, t, n) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === n, this.usage = Jr, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } function h(e, t, n) { l.call(this, new Int8Array(e), t, n) } function u(e, t, n) { l.call(this, new Uint8Array(e), t, n) } function d(e, t, n) { l.call(this, new Uint8ClampedArray(e), t, n) } function p(e, t, n) { l.call(this, new Int16Array(e), t, n) } function f(e, t, n) { l.call(this, new Uint16Array(e), t, n) } function m(e, t, n) { l.call(this, new Int32Array(e), t, n) } function g(e, t, n) { l.call(this, new Uint32Array(e), t, n) } function v(e, t, n) { l.call(this, new Uint16Array(e), t, n) } function y(e, t, n) { l.call(this, new Float32Array(e), t, n) } function x(e, t, n) { l.call(this, new Float64Array(e), t, n) } function _(e) { if (0 === e.length) return -1 / 0; let t = e[0]; for (let n = 1, i = e.length; n < i; ++n)e[n] > t && (t = e[n]); return t } function b(e, t) { return new Ho[e](t) } function E() { Object.defineProperty(this, "id", { value: Uo++ }), this.uuid = na.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } function w(e = new E, t = new Oo) { r.call(this), this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets() } function M(e, t, n, i, r, a, o, s, c, l, h, u) { Ko.fromBufferAttribute(r, l), Zo.fromBufferAttribute(r, h), Jo.fromBufferAttribute(r, u); const d = e.morphTargetInfluences; if (t.morphTargets && a && d) { ts.set(0, 0, 0), ns.set(0, 0, 0), is.set(0, 0, 0); for (let e = 0, t = a.length; e < t; e++) { const t = d[e], n = a[e]; 0 !== t && (Qo.fromBufferAttribute(n, l), $o.fromBufferAttribute(n, h), es.fromBufferAttribute(n, u), o ? (ts.addScaledVector(Qo, t), ns.addScaledVector($o, t), is.addScaledVector(es, t)) : (ts.addScaledVector(Qo.sub(Ko), t), ns.addScaledVector($o.sub(Zo), t), is.addScaledVector(es.sub(Jo), t))) } Ko.add(ts), Zo.add(ns), Jo.add(is) } e.isSkinnedMesh && t.skinning && (e.boneTransform(l, Ko), e.boneTransform(h, Zo), e.boneTransform(u, Jo)); const p = function (e, t, n, i, r, a, o, s) { let c; if (null === (c = t.side === Mn ? i.intersectTriangle(o, a, r, !0, s) : i.intersectTriangle(r, a, o, t.side !== Tn, s))) return null; cs.copy(s), cs.applyMatrix4(e.matrixWorld); const l = n.ray.origin.distanceTo(cs); return l < n.near || l > n.far ? null : { distance: l, point: cs.clone(), object: e } }(e, t, n, i, Ko, Zo, Jo, ss); if (p) { s && (rs.fromBufferAttribute(s, l), as.fromBufferAttribute(s, h), os.fromBufferAttribute(s, u), p.uv = Lo.getUV(ss, Ko, Zo, Jo, rs, as, os, new ia)), c && (rs.fromBufferAttribute(c, l), as.fromBufferAttribute(c, h), os.fromBufferAttribute(c, u), p.uv2 = Lo.getUV(ss, Ko, Zo, Jo, rs, as, os, new ia)); const e = { a: l, b: h, c: u, normal: new pa, materialIndex: 0 }; Lo.getNormal(Ko, Zo, Jo, e.normal), p.face = e } return p } function T(e) { const t = {}; for (const n in e) { t[n] = {}; for (const i in e[n]) { const r = e[n][i]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r } } return t } function S(e) { const t = {}; for (let n = 0; n < e.length; n++) { const i = T(e[n]); for (const e in i) t[e] = i[e] } return t } function A(e) { a.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = us, this.fragmentShader = ds, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e)) } function R() { r.call(this), this.type = "Camera", this.matrixWorldInverse = new Va, this.projectionMatrix = new Va, this.projectionMatrixInverse = new Va } function L(e = 50, t = 1, n = .1, i = 2e3) { R.call(this), this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } function C() { function e(n, a) { i(n, a), r = t.requestAnimationFrame(e) } let t = null, n = !1, i = null, r = null; return { start: function () { !0 !== n && null !== i && (r = t.requestAnimationFrame(e), n = !0) }, stop: function () { t.cancelAnimationFrame(r), n = !1 }, setAnimationLoop: function (e) { i = e }, setContext: function (e) { t = e } } } function P(e, t) { const n = t.isWebGL2, i = new WeakMap; return { get: function (e) { return e.isInterleavedBufferAttribute && (e = e.data), i.get(e) }, remove: function (t) { t.isInterleavedBufferAttribute && (t = t.data); const n = i.get(t); n && (e.deleteBuffer(n.buffer), i.delete(t)) }, update: function (t, r) { if (t.isGLBufferAttribute) { const e = i.get(t); return void ((!e || e.version < t.version) && i.set(t, { buffer: t.buffer, type: t.type, bytesPerElement: t.elementSize, version: t.version })) } t.isInterleavedBufferAttribute && (t = t.data); const a = i.get(t); void 0 === a ? i.set(t, function (t, i) { const r = t.array, a = t.usage, o = e.createBuffer(); e.bindBuffer(i, o), e.bufferData(i, r, a), t.onUploadCallback(); let s = e.FLOAT; return r instanceof Float32Array ? s = e.FLOAT : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? t.isFloat16BufferAttribute ? n ? s = e.HALF_FLOAT : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : s = e.UNSIGNED_SHORT : r instanceof Int16Array ? s = e.SHORT : r instanceof Uint32Array ? s = e.UNSIGNED_INT : r instanceof Int32Array ? s = e.INT : r instanceof Int8Array ? s = e.BYTE : r instanceof Uint8Array && (s = e.UNSIGNED_BYTE), { buffer: o, type: s, bytesPerElement: r.BYTES_PER_ELEMENT, version: t.version } }(t, r)) : a.version < t.version && (function (t, i, r) { const a = i.array, o = i.updateRange; e.bindBuffer(r, t), -1 === o.count ? e.bufferSubData(r, 0, a) : (n ? e.bufferSubData(r, o.offset * a.BYTES_PER_ELEMENT, a, o.offset, o.count) : e.bufferSubData(r, o.offset * a.BYTES_PER_ELEMENT, a.subarray(o.offset, o.offset + o.count)), o.count = -1) }(a.buffer, t, r), a.version = t.version) } } } function N(e, t, n, i) { function r(t) { return i.isWebGL2 ? e.bindVertexArray(t) : m.bindVertexArrayOES(t) } function a(t) { return i.isWebGL2 ? e.deleteVertexArray(t) : m.deleteVertexArrayOES(t) } function o(e) { const t = [], n = [], i = []; for (let e = 0; e < f; e++)t[e] = 0, n[e] = 0, i[e] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: t, enabledAttributes: n, attributeDivisors: i, object: e, attributes: {}, index: null } } function s() { const e = x.newAttributes; for (let t = 0, n = e.length; t < n; t++)e[t] = 0 } function c(e) { l(e, 0) } function l(n, r) { const a = x.newAttributes, o = x.enabledAttributes, s = x.attributeDivisors; if (a[n] = 1, 0 === o[n] && (e.enableVertexAttribArray(n), o[n] = 1), s[n] !== r) { (i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), s[n] = r } } function h() { const t = x.newAttributes, n = x.enabledAttributes; for (let i = 0, r = n.length; i < r; i++)n[i] !== t[i] && (e.disableVertexAttribArray(i), n[i] = 0) } function u(t, n, r, a, o, s) { !0 !== i.isWebGL2 || r !== e.INT && r !== e.UNSIGNED_INT ? e.vertexAttribPointer(t, n, r, a, o, s) : e.vertexAttribIPointer(t, n, r, o, s) } function d() { p(), x !== y && r((x = y).object) } function p() { y.geometry = null, y.program = null, y.wireframe = !1 } const f = e.getParameter(e.MAX_VERTEX_ATTRIBS), m = i.isWebGL2 ? null : t.get("OES_vertex_array_object"), g = i.isWebGL2 || null !== m, v = {}, y = o(null); let x = y; return { setup: function (a, d, p, f, y) { let _ = !1; if (g) { const t = function (t, n, r) { const a = !0 === r.wireframe; let s = v[t.id]; void 0 === s && (s = {}, v[t.id] = s); let c = s[n.id]; void 0 === c && (c = {}, s[n.id] = c); let l = c[a]; return void 0 === l && (l = o(i.isWebGL2 ? e.createVertexArray() : m.createVertexArrayOES()), c[a] = l), l }(f, p, d); x !== t && r((x = t).object), (_ = function (e, t) { const n = x.attributes, i = e.attributes; let r = 0; for (const e in i) { const t = n[e], a = i[e]; if (void 0 === t) return !0; if (t.attribute !== a) return !0; if (t.data !== a.data) return !0; r++ } return x.attributesNum !== r || x.index !== t }(f, y)) && function (e, t) { const n = {}, i = e.attributes; let r = 0; for (const e in i) { const t = i[e], a = {}; a.attribute = t, t.data && (a.data = t.data), n[e] = a, r++ } x.attributes = n, x.attributesNum = r, x.index = t }(f, y) } else { const e = !0 === d.wireframe; x.geometry === f.id && x.program === p.id && x.wireframe === e || (x.geometry = f.id, x.program = p.id, x.wireframe = e, _ = !0) } !0 === a.isInstancedMesh && (_ = !0), null !== y && n.update(y, e.ELEMENT_ARRAY_BUFFER), _ && (function (r, a, o, d) { if (!1 === i.isWebGL2 && (r.isInstancedMesh || d.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return; s(); const p = d.attributes, f = o.getAttributes(), m = a.defaultAttributeValues; for (const t in f) { const i = f[t]; if (i >= 0) { const a = p[t]; if (void 0 !== a) { const t = a.normalized, r = a.itemSize, o = n.get(a); if (void 0 === o) continue; const s = o.buffer, h = o.type, p = o.bytesPerElement; if (a.isInterleavedBufferAttribute) { const n = a.data, o = n.stride, f = a.offset; n && n.isInstancedInterleavedBuffer ? (l(i, n.meshPerAttribute), void 0 === d._maxInstanceCount && (d._maxInstanceCount = n.meshPerAttribute * n.count)) : c(i), e.bindBuffer(e.ARRAY_BUFFER, s), u(i, r, h, t, o * p, f * p) } else a.isInstancedBufferAttribute ? (l(i, a.meshPerAttribute), void 0 === d._maxInstanceCount && (d._maxInstanceCount = a.meshPerAttribute * a.count)) : c(i), e.bindBuffer(e.ARRAY_BUFFER, s), u(i, r, h, t, 0, 0) } else if ("instanceMatrix" === t) { const t = n.get(r.instanceMatrix); if (void 0 === t) continue; const a = t.buffer, o = t.type; l(i + 0, 1), l(i + 1, 1), l(i + 2, 1), l(i + 3, 1), e.bindBuffer(e.ARRAY_BUFFER, a), e.vertexAttribPointer(i + 0, 4, o, !1, 64, 0), e.vertexAttribPointer(i + 1, 4, o, !1, 64, 16), e.vertexAttribPointer(i + 2, 4, o, !1, 64, 32), e.vertexAttribPointer(i + 3, 4, o, !1, 64, 48) } else if ("instanceColor" === t) { const t = n.get(r.instanceColor); if (void 0 === t) continue; const a = t.buffer, o = t.type; l(i, 1), e.bindBuffer(e.ARRAY_BUFFER, a), e.vertexAttribPointer(i, 3, o, !1, 12, 0) } else if (void 0 !== m) { const n = m[t]; if (void 0 !== n) switch (n.length) { case 2: e.vertexAttrib2fv(i, n); break; case 3: e.vertexAttrib3fv(i, n); break; case 4: e.vertexAttrib4fv(i, n); break; default: e.vertexAttrib1fv(i, n) } } } } h() }(a, d, p, f), null !== y && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n.get(y).buffer)) }, reset: d, resetDefaultState: p, dispose: function () { d(); for (const e in v) { const t = v[e]; for (const e in t) { const n = t[e]; for (const e in n) a(n[e].object), delete n[e]; delete t[e] } delete v[e] } }, releaseStatesOfGeometry: function (e) { if (void 0 === v[e.id]) return; const t = v[e.id]; for (const e in t) { const n = t[e]; for (const e in n) a(n[e].object), delete n[e]; delete t[e] } delete v[e.id] }, releaseStatesOfProgram: function (e) { for (const t in v) { const n = v[t]; if (void 0 === n[e.id]) continue; const i = n[e.id]; for (const e in i) a(i[e].object), delete i[e]; delete n[e.id] } }, initAttributes: s, enableAttribute: c, disableUnusedAttributes: h } } function I(e, t) { return e[0] - t[0] } function D(e, t) { return Math.abs(t[1]) - Math.abs(e[1]) } function O(e, t, n) { const i = e[0]; if (i <= 0 || i > 0) return e; const r = t * n; let a = Cs[r]; if (void 0 === a && (a = new Float32Array(r), Cs[r] = a), 0 !== t) { i.toArray(a, 0); for (let i = 1, r = 0; i !== t; ++i)r += n, e[i].toArray(a, r) } return a } function F(e, t) { if (e.length !== t.length) return !1; for (let n = 0, i = e.length; n < i; n++)if (e[n] !== t[n]) return !1; return !0 } function B(e, t) { for (let n = 0, i = t.length; n < i; n++)e[n] = t[n] } function H(e, t) { let n = Ps[t]; void 0 === n && (n = new Int32Array(t), Ps[t] = n); for (let i = 0; i !== t; ++i)n[i] = e.allocateTextureUnit(); return n } function U(e, t) { const n = this.cache; n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t) } function k(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y); else { if (F(n, t)) return; e.uniform2fv(this.addr, t), B(n, t) } } function G(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z); else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b); else { if (F(n, t)) return; e.uniform3fv(this.addr, t), B(n, t) } } function z(e, t) { const n = this.cache; if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w); else { if (F(n, t)) return; e.uniform4fv(this.addr, t), B(n, t) } } function V(e, t) { const n = this.cache, i = t.elements; if (void 0 === i) { if (F(n, t)) return; e.uniformMatrix2fv(this.addr, !1, t), B(n, t) } else { if (F(n, i)) return; Ds.set(i), e.uniformMatrix2fv(this.addr, !1, Ds), B(n, i) } } function W(e, t) { const n = this.cache, i = t.elements; if (void 0 === i) { if (F(n, t)) return; e.uniformMatrix3fv(this.addr, !1, t), B(n, t) } else { if (F(n, i)) return; Is.set(i), e.uniformMatrix3fv(this.addr, !1, Is), B(n, i) } } function j(e, t) { const n = this.cache, i = t.elements; if (void 0 === i) { if (F(n, t)) return; e.uniformMatrix4fv(this.addr, !1, t), B(n, t) } else { if (F(n, i)) return; Ns.set(i), e.uniformMatrix4fv(this.addr, !1, Ns), B(n, i) } } function X(e, t) { const n = this.cache; n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t) } function q(e, t) { const n = this.cache; F(n, t) || (e.uniform2iv(this.addr, t), B(n, t)) } function Y(e, t) { const n = this.cache; F(n, t) || (e.uniform3iv(this.addr, t), B(n, t)) } function K(e, t) { const n = this.cache; F(n, t) || (e.uniform4iv(this.addr, t), B(n, t)) } function Z(e, t) { const n = this.cache; n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t) } function J(e, t) { const n = this.cache; F(n, t) || (e.uniform2uiv(this.addr, t), B(n, t)) } function Q(e, t) { const n = this.cache; F(n, t) || (e.uniform3uiv(this.addr, t), B(n, t)) } function $(e, t) { const n = this.cache; F(n, t) || (e.uniform4uiv(this.addr, t), B(n, t)) } function ee(e, t, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(t || Ss, r) } function te(e, t, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || Rs, r) } function ne(e, t, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(t || Ls, r) } function ie(e, t, n) { const i = this.cache, r = n.allocateTextureUnit(); i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(t || As, r) } function re(e, t) { e.uniform1fv(this.addr, t) } function ae(e, t) { const n = O(t, this.size, 2); e.uniform2fv(this.addr, n) } function oe(e, t) { const n = O(t, this.size, 3); e.uniform3fv(this.addr, n) } function se(e, t) { const n = O(t, this.size, 4); e.uniform4fv(this.addr, n) } function ce(e, t) { const n = O(t, this.size, 4); e.uniformMatrix2fv(this.addr, !1, n) } function le(e, t) { const n = O(t, this.size, 9); e.uniformMatrix3fv(this.addr, !1, n) } function he(e, t) { const n = O(t, this.size, 16); e.uniformMatrix4fv(this.addr, !1, n) } function ue(e, t) { e.uniform1iv(this.addr, t) } function de(e, t) { e.uniform2iv(this.addr, t) } function pe(e, t) { e.uniform3iv(this.addr, t) } function fe(e, t) { e.uniform4iv(this.addr, t) } function me(e, t) { e.uniform1uiv(this.addr, t) } function ge(e, t) { e.uniform2uiv(this.addr, t) } function ve(e, t) { e.uniform3uiv(this.addr, t) } function ye(e, t) { e.uniform4uiv(this.addr, t) } function xe(e, t, n) { const i = t.length, r = H(n, i); e.uniform1iv(this.addr, r); for (let e = 0; e !== i; ++e)n.safeSetTexture2D(t[e] || Ss, r[e]) } function _e(e, t, n) { const i = t.length, r = H(n, i); e.uniform1iv(this.addr, r); for (let e = 0; e !== i; ++e)n.safeSetTextureCube(t[e] || Ls, r[e]) } function be(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.setValue = function (e) { switch (e) { case 5126: return U; case 35664: return k; case 35665: return G; case 35666: return z; case 35674: return V; case 35675: return W; case 35676: return j; case 5124: case 35670: return X; case 35667: case 35671: return q; case 35668: case 35672: return Y; case 35669: case 35673: return K; case 5125: return Z; case 36294: return J; case 36295: return Q; case 36296: return $; case 35678: case 36198: case 36298: case 36306: case 35682: return ee; case 35679: case 36299: case 36307: return te; case 35680: case 36300: case 36308: case 36293: return ne; case 36289: case 36303: case 36311: case 36292: return ie } }(t.type) } function Ee(e, t, n) { this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = function (e) { switch (e) { case 5126: return re; case 35664: return ae; case 35665: return oe; case 35666: return se; case 35674: return ce; case 35675: return le; case 35676: return he; case 5124: case 35670: return ue; case 35667: case 35671: return de; case 35668: case 35672: return pe; case 35669: case 35673: return fe; case 5125: return me; case 36294: return ge; case 36295: return ve; case 36296: return ye; case 35678: case 36198: case 36298: case 36306: case 35682: return xe; case 35680: case 36300: case 36308: case 36293: return _e } }(t.type) } function we(e) { this.id = e, this.seq = [], this.map = {} } function Me(e, t) { e.seq.push(t), e.map[t.id] = t } function Te(e, t, n) { const i = e.name, r = i.length; for (Os.lastIndex = 0; ;) { const a = Os.exec(i), o = Os.lastIndex; let s = a[1]; const c = "]" === a[2], l = a[3]; if (c && (s |= 0), void 0 === l || "[" === l && o + 2 === r) { Me(n, void 0 === l ? new be(s, e, t) : new Ee(s, e, t)); break } { let e = n.map[s]; void 0 === e && Me(n, e = new we(s)), n = e } } } function Se(e, t) { this.seq = [], this.map = {}; const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS); for (let i = 0; i < n; ++i) { const n = e.getActiveUniform(t, i); Te(n, e.getUniformLocation(t, n.name), this) } } function Ae(e, t, n) { const i = e.createShader(t); return e.shaderSource(i, n), e.compileShader(i), i } function Re(e) { switch (e) { case Hr: return ["Linear", "( value )"]; case Ur: return ["sRGB", "( value )"]; case Gr: return ["RGBE", "( value )"]; case Vr: return ["RGBM", "( value, 7.0 )"]; case Wr: return ["RGBM", "( value, 16.0 )"]; case jr: return ["RGBD", "( value, 256.0 )"]; case kr: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; case zr: return ["LogLuv", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", e), ["Linear", "( value )"] } } function Le(e, t, n) { const i = e.getShaderParameter(t, e.COMPILE_STATUS), r = e.getShaderInfoLog(t).trim(); if (i && "" === r) return ""; return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function (e) { const t = e.split("\n"); for (let e = 0; e < t.length; e++)t[e] = e + 1 + ": " + t[e]; return t.join("\n") }(e.getShaderSource(t)) } function Ce(e, t) { const n = Re(t); return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }" } function Pe(e) { return "" !== e } function Ne(e, t) { return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows) } function Ie(e, t) { return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection) } function De(e) { return e.replace(Bs, Oe) } function Oe(e, t) { const n = bs[t]; if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">"); return De(n) } function Fe(e) { return e.replace(Us, He).replace(Hs, Be) } function Be(e, t, n, i) { return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), He(e, t, n, i) } function He(e, t, n, i) { let r = ""; for (let e = parseInt(t); e < parseInt(n); e++)r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e); return r } function Ue(e) { let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;"; return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t } function ke(e, t, n, i) { const r = e.getContext(), a = n.defines; let o = n.vertexShader, s = n.fragmentShader; const c = function (e) { let t = "SHADOWMAP_TYPE_BASIC"; return e.shadowMapType === _n ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === bn ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === En && (t = "SHADOWMAP_TYPE_VSM"), t }(n), l = function (e) { let t = "ENVMAP_TYPE_CUBE"; if (e.envMap) switch (e.envMapMode) { case ui: case di: t = "ENVMAP_TYPE_CUBE"; break; case mi: case gi: t = "ENVMAP_TYPE_CUBE_UV" }return t }(n), h = function (e) { let t = "ENVMAP_MODE_REFLECTION"; if (e.envMap) switch (e.envMapMode) { case di: case gi: t = "ENVMAP_MODE_REFRACTION" }return t }(n), u = function (e) { let t = "ENVMAP_BLENDING_NONE"; if (e.envMap) switch (e.combine) { case ni: t = "ENVMAP_BLENDING_MULTIPLY"; break; case ii: t = "ENVMAP_BLENDING_MIX"; break; case ri: t = "ENVMAP_BLENDING_ADD" }return t }(n), d = e.gammaFactor > 0 ? e.gammaFactor : 1, p = n.isWebGL2 ? "" : function (e) { return [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Pe).join("\n") }(n), f = function (e) { const t = []; for (const n in e) { const i = e[n]; !1 !== i && t.push("#define " + n + " " + i) } return t.join("\n") }(a), m = r.createProgram(); let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : ""; n.isRawShaderMaterial ? ((g = [f].filter(Pe).join("\n")).length > 0 && (g += "\n"), (v = [p, f].filter(Pe).join("\n")).length > 0 && (v += "\n")) : (g = [Ue(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Pe).join("\n"), v = [p, Ue(n), "#define SHADER_NAME " + n.shaderName, f, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + l : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== ai ? "#define TONE_MAPPING" : "", n.toneMapping !== ai ? bs.tonemapping_pars_fragment : "", n.toneMapping !== ai ? function (e, t) { let n; switch (t) { case oi: n = "Linear"; break; case si: n = "Reinhard"; break; case ci: n = "OptimizedCineon"; break; case li: n = "ACESFilmic"; break; case hi: n = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear" }return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }" }("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", bs.encodings_pars_fragment, n.map ? Ce("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Ce("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Ce("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Ce("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? Ce("lightMapTexelToLinear", n.lightMapEncoding) : "", function (e, t) { const n = Re(t); return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }" }("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Pe).join("\n")), o = Ie(o = Ne(o = De(o), n), n), s = Ie(s = Ne(s = De(s), n), n), o = Fe(o), s = Fe(s), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", g = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", n.glslVersion === $r ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === $r ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v); const x = y + g + o, _ = y + v + s, b = Ae(r, r.VERTEX_SHADER, x), E = Ae(r, r.FRAGMENT_SHADER, _); if (r.attachShader(m, b), r.attachShader(m, E), void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), e.debug.checkShaderErrors) { const e = r.getProgramInfoLog(m).trim(), t = r.getShaderInfoLog(b).trim(), n = r.getShaderInfoLog(E).trim(); let i = !0, a = !0; if (!1 === r.getProgramParameter(m, r.LINK_STATUS)) { i = !1; const t = Le(r, b, "vertex"), n = Le(r, E, "fragment"); console.error("THREE.WebGLProgram: shader error: ", r.getError(), "gl.VALIDATE_STATUS", r.getProgramParameter(m, r.VALIDATE_STATUS), "gl.getProgramInfoLog", e, t, n) } else "" !== e ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", e) : "" !== t && "" !== n || (a = !1); a && (this.diagnostics = { runnable: i, programLog: e, vertexShader: { log: t, prefix: g }, fragmentShader: { log: n, prefix: v } }) } r.deleteShader(b), r.deleteShader(E); let w; this.getUniforms = function () { return void 0 === w && (w = new Se(r, m)), w }; let M; return this.getAttributes = function () { return void 0 === M && (M = function (e, t) { const n = {}, i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES); for (let r = 0; r < i; r++) { const i = e.getActiveAttrib(t, r).name; n[i] = e.getAttribLocation(t, i) } return n }(r, m)), M }, this.destroy = function () { i.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0 }, this.name = n.shaderName, this.id = Fs++, this.cacheKey = t, this.usedTimes = 1, this.program = m, this.vertexShader = b, this.fragmentShader = E, this } function Ge(e, t, n, i, r, a) { function o(e) { let t; return e && e.isTexture ? t = e.encoding : e && e.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t = e.texture.encoding) : t = Hr, t } const s = [], c = i.isWebGL2, l = i.logarithmicDepthBuffer, h = i.floatVertexTextures, u = i.maxVertexUniforms, d = i.vertexTextures; let p = i.precision; const f = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, m = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"]; return { getParameters: function (r, s, m, g, v) { const y = g.fog, x = r.isMeshStandardMaterial ? g.environment : null, _ = t.get(r.envMap || x), b = f[r.type], E = v.isSkinnedMesh ? function (e) { const t = e.skeleton.bones; if (h) return 1024; { const e = u, n = Math.floor((e - 20) / 4), i = Math.min(n, t.length); return i < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + i + "."), 0) : i } }(v) : 0; null !== r.precision && (p = i.getMaxPrecision(r.precision)) !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", p, "instead."); let w, M; if (b) { const e = ws[b]; w = e.vertexShader, M = e.fragmentShader } else w = r.vertexShader, M = r.fragmentShader; const T = e.getRenderTarget(); return { isWebGL2: c, shaderID: b, shaderName: r.type, vertexShader: w, fragmentShader: M, defines: r.defines, isRawShaderMaterial: !0 === r.isRawShaderMaterial, glslVersion: r.glslVersion, precision: p, instancing: !0 === v.isInstancedMesh, instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor, supportsVertexTextures: d, outputEncoding: null !== T ? o(T.texture) : e.outputEncoding, map: !!r.map, mapEncoding: o(r.map), matcap: !!r.matcap, matcapEncoding: o(r.matcap), envMap: !!_, envMapMode: _ && _.mapping, envMapEncoding: o(_), envMapCubeUV: !!_ && (_.mapping === mi || _.mapping === gi), lightMap: !!r.lightMap, lightMapEncoding: o(r.lightMap), aoMap: !!r.aoMap, emissiveMap: !!r.emissiveMap, emissiveMapEncoding: o(r.emissiveMap), bumpMap: !!r.bumpMap, normalMap: !!r.normalMap, objectSpaceNormalMap: r.normalMapType === Yr, tangentSpaceNormalMap: r.normalMapType === qr, clearcoatMap: !!r.clearcoatMap, clearcoatRoughnessMap: !!r.clearcoatRoughnessMap, clearcoatNormalMap: !!r.clearcoatNormalMap, displacementMap: !!r.displacementMap, roughnessMap: !!r.roughnessMap, metalnessMap: !!r.metalnessMap, specularMap: !!r.specularMap, alphaMap: !!r.alphaMap, gradientMap: !!r.gradientMap, sheen: !!r.sheen, transmissionMap: !!r.transmissionMap, combine: r.combine, vertexTangents: r.normalMap && r.vertexTangents, vertexColors: r.vertexColors, vertexAlphas: !0 === r.vertexColors && v.geometry.attributes.color && 4 === v.geometry.attributes.color.itemSize, vertexUvs: !!(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatMap || r.clearcoatRoughnessMap || r.clearcoatNormalMap || r.displacementMap || r.transmissionMap), uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || r.transmissionMap || !r.displacementMap), fog: !!y, useFog: r.fog, fogExp2: y && y.isFogExp2, flatShading: !!r.flatShading, sizeAttenuation: r.sizeAttenuation, logarithmicDepthBuffer: l, skinning: r.skinning && E > 0, maxBones: E, useVertexTexture: h, morphTargets: r.morphTargets, morphNormals: r.morphNormals, numDirLights: s.directional.length, numPointLights: s.point.length, numSpotLights: s.spot.length, numRectAreaLights: s.rectArea.length, numHemiLights: s.hemi.length, numDirLightShadows: s.directionalShadowMap.length, numPointLightShadows: s.pointShadowMap.length, numSpotLightShadows: s.spotShadowMap.length, numClippingPlanes: a.numPlanes, numClipIntersection: a.numIntersection, dithering: r.dithering, shadowMapEnabled: e.shadowMap.enabled && m.length > 0, shadowMapType: e.shadowMap.type, toneMapping: r.toneMapped ? e.toneMapping : ai, physicallyCorrectLights: e.physicallyCorrectLights, premultipliedAlpha: r.premultipliedAlpha, alphaTest: r.alphaTest, doubleSided: r.side === Tn, flipSided: r.side === Mn, depthPacking: void 0 !== r.depthPacking && r.depthPacking, index0AttributeName: r.index0AttributeName, extensionDerivatives: r.extensions && r.extensions.derivatives, extensionFragDepth: r.extensions && r.extensions.fragDepth, extensionDrawBuffers: r.extensions && r.extensions.drawBuffers, extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD, rendererExtensionFragDepth: c || n.has("EXT_frag_depth"), rendererExtensionDrawBuffers: c || n.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: c || n.has("EXT_shader_texture_lod"), customProgramCacheKey: r.customProgramCacheKey() } }, getProgramCacheKey: function (t) { const n = []; if (t.shaderID ? n.push(t.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines) for (const e in t.defines) n.push(e), n.push(t.defines[e]); if (!1 === t.isRawShaderMaterial) { for (let e = 0; e < m.length; e++)n.push(t[m[e]]); n.push(e.outputEncoding), n.push(e.gammaFactor) } return n.push(t.customProgramCacheKey), n.join() }, getUniforms: function (e) { const t = f[e.type]; let n; if (t) { const e = ws[t]; n = hs.clone(e.uniforms) } else n = e.uniforms; return n }, acquireProgram: function (t, n) { let i; for (let e = 0, t = s.length; e < t; e++) { const t = s[e]; if (t.cacheKey === n) { ++(i = t).usedTimes; break } } return void 0 === i && (i = new ke(e, n, t, r), s.push(i)), i }, releaseProgram: function (e) { if (0 == --e.usedTimes) { const t = s.indexOf(e); s[t] = s[s.length - 1], s.pop(), e.destroy() } }, programs: s } } function ze(e) { function t(t, r, a, s, c, l) { let h = n[i]; const u = e.get(a); return void 0 === h ? (h = { id: t.id, object: t, geometry: r, material: a, program: u.program || o, groupOrder: s, renderOrder: t.renderOrder, z: c, group: l }, n[i] = h) : (h.id = t.id, h.object = t, h.geometry = r, h.material = a, h.program = u.program || o, h.groupOrder = s, h.renderOrder = t.renderOrder, h.z = c, h.group = l), i++, h } const n = []; let i = 0; const r = [], a = [], o = { id: -1 }; return { opaque: r, transparent: a, init: function () { i = 0, r.length = 0, a.length = 0 }, push: function (e, n, i, o, s, c) { const l = t(e, n, i, o, s, c); (!0 === i.transparent ? a : r).push(l) }, unshift: function (e, n, i, o, s, c) { const l = t(e, n, i, o, s, c); (!0 === i.transparent ? a : r).unshift(l) }, finish: function () { for (let e = i, t = n.length; e < t; e++) { const t = n[e]; if (null === t.id) break; t.id = null, t.object = null, t.geometry = null, t.material = null, t.program = null, t.group = null } }, sort: function (e, t) { r.length > 1 && r.sort(e || function (e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id }), a.length > 1 && a.sort(t || function (e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id }) } } } function Ve(e, t) { return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0) } function We(e, t) { const n = new function () { const e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; let n; switch (t.type) { case "DirectionalLight": n = { direction: new pa, color: new Do }; break; case "SpotLight": n = { position: new pa, direction: new pa, color: new Do, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": n = { position: new pa, color: new Do, distance: 0, decay: 0 }; break; case "HemisphereLight": n = { direction: new pa, skyColor: new Do, groundColor: new Do }; break; case "RectAreaLight": n = { color: new Do, position: new pa, halfWidth: new pa, halfHeight: new pa } }return e[t.id] = n, n } } }, i = function () { const e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; let n; switch (t.type) { case "DirectionalLight": case "SpotLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new ia }; break; case "PointLight": n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new ia, shadowCameraNear: 1, shadowCameraFar: 1e3 } }return e[t.id] = n, n } } }(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }; for (let e = 0; e < 9; e++)r.probe.push(new pa); const a = new pa, o = new Va, s = new Va; return { setup: function (a) { let o = 0, s = 0, c = 0; for (let e = 0; e < 9; e++)r.probe[e].set(0, 0, 0); let l = 0, h = 0, u = 0, d = 0, p = 0, f = 0, m = 0, g = 0; a.sort(Ve); for (let e = 0, t = a.length; e < t; e++) { const t = a[e], v = t.color, y = t.intensity, x = t.distance, _ = t.shadow && t.shadow.map ? t.shadow.map.texture : null; if (t.isAmbientLight) o += v.r * y, s += v.g * y, c += v.b * y; else if (t.isLightProbe) for (let e = 0; e < 9; e++)r.probe[e].addScaledVector(t.sh.coefficients[e], y); else if (t.isDirectionalLight) { const e = n.get(t); if (e.color.copy(t.color).multiplyScalar(t.intensity), t.castShadow) { const e = t.shadow, n = i.get(t); n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.directionalShadow[l] = n, r.directionalShadowMap[l] = _, r.directionalShadowMatrix[l] = t.shadow.matrix, f++ } r.directional[l] = e, l++ } else if (t.isSpotLight) { const e = n.get(t); if (e.position.setFromMatrixPosition(t.matrixWorld), e.color.copy(v).multiplyScalar(y), e.distance = x, e.coneCos = Math.cos(t.angle), e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), e.decay = t.decay, t.castShadow) { const e = t.shadow, n = i.get(t); n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, r.spotShadow[u] = n, r.spotShadowMap[u] = _, r.spotShadowMatrix[u] = t.shadow.matrix, g++ } r.spot[u] = e, u++ } else if (t.isRectAreaLight) { const e = n.get(t); e.color.copy(v).multiplyScalar(y), e.halfWidth.set(.5 * t.width, 0, 0), e.halfHeight.set(0, .5 * t.height, 0), r.rectArea[d] = e, d++ } else if (t.isPointLight) { const e = n.get(t); if (e.color.copy(t.color).multiplyScalar(t.intensity), e.distance = t.distance, e.decay = t.decay, t.castShadow) { const e = t.shadow, n = i.get(t); n.shadowBias = e.bias, n.shadowNormalBias = e.normalBias, n.shadowRadius = e.radius, n.shadowMapSize = e.mapSize, n.shadowCameraNear = e.camera.near, n.shadowCameraFar = e.camera.far, r.pointShadow[h] = n, r.pointShadowMap[h] = _, r.pointShadowMatrix[h] = t.shadow.matrix, m++ } r.point[h] = e, h++ } else if (t.isHemisphereLight) { const e = n.get(t); e.skyColor.copy(t.color).multiplyScalar(y), e.groundColor.copy(t.groundColor).multiplyScalar(y), r.hemi[p] = e, p++ } } d > 0 && (t.isWebGL2 ? (r.rectAreaLTC1 = Es.LTC_FLOAT_1, r.rectAreaLTC2 = Es.LTC_FLOAT_2) : !0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Es.LTC_FLOAT_1, r.rectAreaLTC2 = Es.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Es.LTC_HALF_1, r.rectAreaLTC2 = Es.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = s, r.ambient[2] = c; const v = r.hash; v.directionalLength === l && v.pointLength === h && v.spotLength === u && v.rectAreaLength === d && v.hemiLength === p && v.numDirectionalShadows === f && v.numPointShadows === m && v.numSpotShadows === g || (r.directional.length = l, r.spot.length = u, r.rectArea.length = d, r.point.length = h, r.hemi.length = p, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = m, r.pointShadowMap.length = m, r.spotShadow.length = g, r.spotShadowMap.length = g, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = m, r.spotShadowMatrix.length = g, v.directionalLength = l, v.pointLength = h, v.spotLength = u, v.rectAreaLength = d, v.hemiLength = p, v.numDirectionalShadows = f, v.numPointShadows = m, v.numSpotShadows = g, r.version = ks++) }, setupView: function (e, t) { let n = 0, i = 0, c = 0, l = 0, h = 0; const u = t.matrixWorldInverse; for (let t = 0, d = e.length; t < d; t++) { const d = e[t]; if (d.isDirectionalLight) { const e = r.directional[n]; e.direction.setFromMatrixPosition(d.matrixWorld), a.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(a), e.direction.transformDirection(u), n++ } else if (d.isSpotLight) { const e = r.spot[c]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), e.direction.setFromMatrixPosition(d.matrixWorld), a.setFromMatrixPosition(d.target.matrixWorld), e.direction.sub(a), e.direction.transformDirection(u), c++ } else if (d.isRectAreaLight) { const e = r.rectArea[l]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), s.identity(), o.copy(d.matrixWorld), o.premultiply(u), s.extractRotation(o), e.halfWidth.set(.5 * d.width, 0, 0), e.halfHeight.set(0, .5 * d.height, 0), e.halfWidth.applyMatrix4(s), e.halfHeight.applyMatrix4(s), l++ } else if (d.isPointLight) { const e = r.point[i]; e.position.setFromMatrixPosition(d.matrixWorld), e.position.applyMatrix4(u), i++ } else if (d.isHemisphereLight) { const e = r.hemi[h]; e.direction.setFromMatrixPosition(d.matrixWorld), e.direction.transformDirection(u), e.direction.normalize(), h++ } } }, state: r } } function je(e, t) { const n = new We(e, t), i = [], r = []; return { init: function () { i.length = 0, r.length = 0 }, state: { lightsArray: i, shadowsArray: r, lights: n }, setupLights: function () { n.setup(i) }, setupLightsView: function (e) { n.setupView(i, e) }, pushLight: function (e) { i.push(e) }, pushShadow: function (e) { r.push(e) } } } function Xe(e, t, n) { function i(e, t, n) { const i = e << 0 | t << 1 | n << 2; let r = d[i]; return void 0 === r && (r = new Gs({ depthPacking: Xr, morphTargets: e, skinning: t }), d[i] = r), r } function r(e, t, n) { const i = e << 0 | t << 1 | n << 2; let r = p[i]; return void 0 === r && (r = new zs({ morphTargets: e, skinning: t }), p[i] = r), r } function a(t, n, a, o, s, c, l) { let h = null, u = i, d = t.customDepthMaterial; if (!0 === o.isPointLight && (u = r, d = t.customDistanceMaterial), void 0 === d) { let e = !1; !0 === a.morphTargets && (e = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0); let i = !1; !0 === t.isSkinnedMesh && (!0 === a.skinning ? i = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t)); h = u(e, i, !0 === t.isInstancedMesh) } else h = d; if (e.localClippingEnabled && !0 === a.clipShadows && 0 !== a.clippingPlanes.length) { const e = h.uuid, t = a.uuid; let n = f[e]; void 0 === n && (n = {}, f[e] = n); let i = n[t]; void 0 === i && (i = h.clone(), n[t] = i), h = i } return h.visible = a.visible, h.wireframe = a.wireframe, h.side = l === En ? null !== a.shadowSide ? a.shadowSide : a.side : null !== a.shadowSide ? a.shadowSide : g[a.side], h.clipShadows = a.clipShadows, h.clippingPlanes = a.clippingPlanes, h.clipIntersection = a.clipIntersection, h.wireframeLinewidth = a.wireframeLinewidth, h.linewidth = a.linewidth, !0 === o.isPointLight && !0 === h.isMeshDistanceMaterial && (h.referencePosition.setFromMatrixPosition(o.matrixWorld), h.nearDistance = s, h.farDistance = c), h } function o(n, i, r, c, l) { if (!1 === n.visible) return; if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && l === En) && (!n.frustumCulled || s.intersectsObject(n))) { n.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, n.matrixWorld); const i = t.update(n), o = n.material; if (Array.isArray(o)) { const t = i.groups; for (let s = 0, h = t.length; s < h; s++) { const h = t[s], u = o[h.materialIndex]; if (u && u.visible) { const t = a(n, i, u, c, r.near, r.far, l); e.renderBufferDirect(r, null, i, t, n, h) } } } else if (o.visible) { const t = a(n, i, o, c, r.near, r.far, l); e.renderBufferDirect(r, null, i, t, n, null) } } const h = n.children; for (let e = 0, t = h.length; e < t; e++)o(h[e], i, r, c, l) } let s = new xs; const c = new ia, h = new ia, u = new la, d = [], p = [], f = {}, m = n.maxTextureSize, g = { 0: Mn, 1: wn, 2: Tn }, v = new A({ defines: { SAMPLE_RATE: .25, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new ia }, radius: { value: 4 } }, vertexShader: Ws, fragmentShader: Vs }), y = v.clone(); y.defines.HORIZONTAL_PASS = 1; const x = new E; x.setAttribute("position", new l(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); const _ = new w(x, v), b = this; this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = _n, this.render = function (n, i, r) { if (!1 === b.enabled) return; if (!1 === b.autoUpdate && !1 === b.needsUpdate) return; if (0 === n.length) return; const a = e.getRenderTarget(), l = e.getActiveCubeFace(), d = e.getActiveMipmapLevel(), p = e.state; p.setBlending(Sn), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1); for (let a = 0, l = n.length; a < l; a++) { const l = n[a], d = l.shadow; if (void 0 === d) { console.warn("THREE.WebGLShadowMap:", l, "has no shadow."); continue } if (!1 === d.autoUpdate && !1 === d.needsUpdate) continue; c.copy(d.mapSize); const f = d.getFrameExtents(); if (c.multiply(f), h.copy(d.mapSize), (c.x > m || c.y > m) && (c.x > m && (h.x = Math.floor(m / f.x), c.x = h.x * f.x, d.mapSize.x = h.x), c.y > m && (h.y = Math.floor(m / f.y), c.y = h.y * f.y, d.mapSize.y = h.y)), null === d.map && !d.isPointLightShadow && this.type === En) { const e = { minFilter: wi, magFilter: wi, format: ki }; d.map = new ha(c.x, c.y, e), d.map.texture.name = l.name + ".shadowMap", d.mapPass = new ha(c.x, c.y, e), d.camera.updateProjectionMatrix() } if (null === d.map) { const e = { minFilter: _i, magFilter: _i, format: ki }; d.map = new ha(c.x, c.y, e), d.map.texture.name = l.name + ".shadowMap", d.camera.updateProjectionMatrix() } e.setRenderTarget(d.map), e.clear(); const g = d.getViewportCount(); for (let e = 0; e < g; e++) { const t = d.getViewport(e); u.set(h.x * t.x, h.y * t.y, h.x * t.z, h.y * t.w), p.viewport(u), d.updateMatrices(l, e), s = d.getFrustum(), o(i, r, d.camera, l, this.type) } d.isPointLightShadow || this.type !== En || function (n, i) { const r = t.update(_); v.uniforms.shadow_pass.value = n.map.texture, v.uniforms.resolution.value = n.mapSize, v.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(i, null, r, v, _, null), y.uniforms.shadow_pass.value = n.mapPass.texture, y.uniforms.resolution.value = n.mapSize, y.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(i, null, r, y, _, null) }(d, r), d.needsUpdate = !1 } b.needsUpdate = !1, e.setRenderTarget(a, l, d) } } function qe(e, t, n, i, r, a, o) { function s(e, t) { return N ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") } function c(e, t, n, i) { let r = 1; if ((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)), r < 1 || !0 === t) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) { const i = t ? na.floorPowerOfTwo : Math.floor, a = i(r * e.width), o = i(r * e.height); void 0 === P && (P = s(a, o)); const c = n ? s(a, o) : P; c.width = a, c.height = o; return c.getContext("2d").drawImage(e, 0, 0, a, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + a + "x" + o + ")."), c } return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e } return e } function l(e) { return na.isPowerOfTwo(e.width) && na.isPowerOfTwo(e.height) } function h(e, t) { return e.generateMipmaps && t && e.minFilter !== _i && e.minFilter !== wi } function u(t, n, r, a) { e.generateMipmap(t); i.get(n).__maxMipLevel = Math.log2(Math.max(r, a)) } function d(n, i, r) { if (!1 === T) return i; if (null !== n) { if (void 0 !== e[n]) return e[n]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'") } let a = i; return i === e.RED && (r === e.FLOAT && (a = e.R32F), r === e.HALF_FLOAT && (a = e.R16F), r === e.UNSIGNED_BYTE && (a = e.R8)), i === e.RGB && (r === e.FLOAT && (a = e.RGB32F), r === e.HALF_FLOAT && (a = e.RGB16F), r === e.UNSIGNED_BYTE && (a = e.RGB8)), i === e.RGBA && (r === e.FLOAT && (a = e.RGBA32F), r === e.HALF_FLOAT && (a = e.RGBA16F), r === e.UNSIGNED_BYTE && (a = e.RGBA8)), a !== e.R16F && a !== e.R32F && a !== e.RGBA16F && a !== e.RGBA32F || t.get("EXT_color_buffer_float"), a } function p(t) { return t === _i || t === bi || t === Ei ? e.NEAREST : e.LINEAR } function f(t) { const n = t.target; n.removeEventListener("dispose", f), function (t) { const n = i.get(t); if (void 0 === n.__webglInit) return; e.deleteTexture(n.__webglTexture), i.remove(t) }(n), n.isVideoTexture && C.delete(n), o.memory.textures-- } function m(t) { const n = t.target; n.removeEventListener("dispose", m), function (t) { const n = t.texture, r = i.get(t), a = i.get(n); if (!t) return; void 0 !== a.__webglTexture && e.deleteTexture(a.__webglTexture); t.depthTexture && t.depthTexture.dispose(); if (t.isWebGLCubeRenderTarget) for (let t = 0; t < 6; t++)e.deleteFramebuffer(r.__webglFramebuffer[t]), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer[t]); else e.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && e.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && e.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && e.deleteRenderbuffer(r.__webglDepthRenderbuffer); i.remove(n), i.remove(t) }(n), o.memory.textures-- } function g(t, r) { const a = i.get(t); if (t.isVideoTexture && function (e) { const t = o.render.frame; C.get(e) !== t && (C.set(e, t), e.update()) }(t), t.version > 0 && a.__version !== t.version) { const e = t.image; if (void 0 === e) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else { if (!1 !== e.complete) return void _(a, t, r); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } n.activeTexture(e.TEXTURE0 + r), n.bindTexture(e.TEXTURE_2D, a.__webglTexture) } function v(t, r) { const o = i.get(t); t.version > 0 && o.__version !== t.version ? function (t, i, r) { if (6 !== i.image.length) return; x(t, i), n.activeTexture(e.TEXTURE0 + r), n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, i.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, i.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE); const o = i && (i.isCompressedTexture || i.image[0].isCompressedTexture), s = i.image[0] && i.image[0].isDataTexture, p = []; for (let e = 0; e < 6; e++)p[e] = o || s ? s ? i.image[e].image : i.image[e] : c(i.image[e], !1, !0, A); const f = p[0], m = l(f) || T, g = a.convert(i.format), v = a.convert(i.type), _ = d(i.internalFormat, g, v); y(e.TEXTURE_CUBE_MAP, i, m); let b; if (o) { for (let t = 0; t < 6; t++) { b = p[t].mipmaps; for (let r = 0; r < b.length; r++) { const a = b[r]; i.format !== ki && i.format !== Ui ? null !== g ? n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, _, a.width, a.height, 0, a.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, _, a.width, a.height, 0, g, v, a.data) } } t.__maxMipLevel = b.length - 1 } else { b = i.mipmaps; for (let t = 0; t < 6; t++)if (s) { n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, _, p[t].width, p[t].height, 0, g, v, p[t].data); for (let i = 0; i < b.length; i++) { const r = b[i].image[t].image; n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, _, r.width, r.height, 0, g, v, r.data) } } else { n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, _, g, v, p[t]); for (let i = 0; i < b.length; i++) { const r = b[i]; n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, _, g, v, r.image[t]) } } t.__maxMipLevel = b.length } h(i, m) && u(e.TEXTURE_CUBE_MAP, i, f.width, f.height); t.__version = i.version, i.onUpdate && i.onUpdate(i) }(o, t, r) : (n.activeTexture(e.TEXTURE0 + r), n.bindTexture(e.TEXTURE_CUBE_MAP, o.__webglTexture)) } function y(n, a, o) { if (o ? (e.texParameteri(n, e.TEXTURE_WRAP_S, D[a.wrapS]), e.texParameteri(n, e.TEXTURE_WRAP_T, D[a.wrapT]), n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, D[a.wrapR]), e.texParameteri(n, e.TEXTURE_MAG_FILTER, O[a.magFilter]), e.texParameteri(n, e.TEXTURE_MIN_FILTER, O[a.minFilter])) : (e.texParameteri(n, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(n, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, e.CLAMP_TO_EDGE), a.wrapS === yi && a.wrapT === yi || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, e.TEXTURE_MAG_FILTER, p(a.magFilter)), e.texParameteri(n, e.TEXTURE_MIN_FILTER, p(a.minFilter)), a.minFilter !== _i && a.minFilter !== wi && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === t.has("EXT_texture_filter_anisotropic")) { const o = t.get("EXT_texture_filter_anisotropic"); if (a.type === Ni && !1 === t.has("OES_texture_float_linear")) return; if (!1 === T && a.type === Ii && !1 === t.has("OES_texture_half_float_linear")) return; (a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (e.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), i.get(a).__currentAnisotropy = a.anisotropy) } } function x(t, n) { void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", f), t.__webglTexture = e.createTexture(), o.memory.textures++) } function _(t, i, r) { let o = e.TEXTURE_2D; i.isDataTexture2DArray && (o = e.TEXTURE_2D_ARRAY), i.isDataTexture3D && (o = e.TEXTURE_3D), x(t, i), n.activeTexture(e.TEXTURE0 + r), n.bindTexture(o, t.__webglTexture), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, i.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, i.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE); const s = function (e) { return !T && (e.wrapS !== yi || e.wrapT !== yi || e.minFilter !== _i && e.minFilter !== wi) }(i) && !1 === l(i.image), p = c(i.image, s, !1, R), f = l(p) || T, m = a.convert(i.format); let g = a.convert(i.type), v = d(i.internalFormat, m, g); y(o, i, f); let _; const b = i.mipmaps; if (i.isDepthTexture) v = e.DEPTH_COMPONENT, T ? v = i.type === Ni ? e.DEPTH_COMPONENT32F : i.type === Pi ? e.DEPTH_COMPONENT24 : i.type === Bi ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT16 : i.type === Ni && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === Wi && v === e.DEPTH_COMPONENT && i.type !== Li && i.type !== Pi && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = Li, g = a.convert(i.type)), i.format === ji && v === e.DEPTH_COMPONENT && (v = e.DEPTH_STENCIL, i.type !== Bi && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Bi, g = a.convert(i.type))), n.texImage2D(e.TEXTURE_2D, 0, v, p.width, p.height, 0, m, g, null); else if (i.isDataTexture) if (b.length > 0 && f) { for (let t = 0, i = b.length; t < i; t++)_ = b[t], n.texImage2D(e.TEXTURE_2D, t, v, _.width, _.height, 0, m, g, _.data); i.generateMipmaps = !1, t.__maxMipLevel = b.length - 1 } else n.texImage2D(e.TEXTURE_2D, 0, v, p.width, p.height, 0, m, g, p.data), t.__maxMipLevel = 0; else if (i.isCompressedTexture) { for (let t = 0, r = b.length; t < r; t++)_ = b[t], i.format !== ki && i.format !== Ui ? null !== m ? n.compressedTexImage2D(e.TEXTURE_2D, t, v, _.width, _.height, 0, _.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(e.TEXTURE_2D, t, v, _.width, _.height, 0, m, g, _.data); t.__maxMipLevel = b.length - 1 } else if (i.isDataTexture2DArray) n.texImage3D(e.TEXTURE_2D_ARRAY, 0, v, p.width, p.height, p.depth, 0, m, g, p.data), t.__maxMipLevel = 0; else if (i.isDataTexture3D) n.texImage3D(e.TEXTURE_3D, 0, v, p.width, p.height, p.depth, 0, m, g, p.data), t.__maxMipLevel = 0; else if (b.length > 0 && f) { for (let t = 0, i = b.length; t < i; t++)_ = b[t], n.texImage2D(e.TEXTURE_2D, t, v, m, g, _); i.generateMipmaps = !1, t.__maxMipLevel = b.length - 1 } else n.texImage2D(e.TEXTURE_2D, 0, v, m, g, p), t.__maxMipLevel = 0; h(i, f) && u(o, i, p.width, p.height), t.__version = i.version, i.onUpdate && i.onUpdate(i) } function b(t, r, o, s) { const c = r.texture, l = a.convert(c.format), h = a.convert(c.type), u = d(c.internalFormat, l, h); s === e.TEXTURE_3D || s === e.TEXTURE_2D_ARRAY ? n.texImage3D(s, 0, u, r.width, r.height, r.depth, 0, l, h, null) : n.texImage2D(s, 0, u, r.width, r.height, 0, l, h, null), n.bindFramebuffer(e.FRAMEBUFFER, t), e.framebufferTexture2D(e.FRAMEBUFFER, o, s, i.get(c).__webglTexture, 0), n.bindFramebuffer(e.FRAMEBUFFER, null) } function E(t, n, i) { if (e.bindRenderbuffer(e.RENDERBUFFER, t), n.depthBuffer && !n.stencilBuffer) { let r = e.DEPTH_COMPONENT16; if (i) { const t = n.depthTexture; t && t.isDepthTexture && (t.type === Ni ? r = e.DEPTH_COMPONENT32F : t.type === Pi && (r = e.DEPTH_COMPONENT24)); const i = M(n); e.renderbufferStorageMultisample(e.RENDERBUFFER, i, r, n.width, n.height) } else e.renderbufferStorage(e.RENDERBUFFER, r, n.width, n.height); e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t) } else if (n.depthBuffer && n.stencilBuffer) { if (i) { const t = M(n); e.renderbufferStorageMultisample(e.RENDERBUFFER, t, e.DEPTH24_STENCIL8, n.width, n.height) } else e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, n.width, n.height); e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, t) } else { const t = n.texture, r = a.convert(t.format), o = a.convert(t.type), s = d(t.internalFormat, r, o); if (i) { const t = M(n); e.renderbufferStorageMultisample(e.RENDERBUFFER, t, s, n.width, n.height) } else e.renderbufferStorage(e.RENDERBUFFER, s, n.width, n.height) } e.bindRenderbuffer(e.RENDERBUFFER, null) } function w(t) { const r = i.get(t), a = !0 === t.isWebGLCubeRenderTarget; if (t.depthTexture) { if (a) throw new Error("target.depthTexture not supported in Cube render targets"); !function (t, r) { if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (n.bindFramebuffer(e.FRAMEBUFFER, t), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), g(r.depthTexture, 0); const a = i.get(r.depthTexture).__webglTexture; if (r.depthTexture.format === Wi) e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, a, 0); else { if (r.depthTexture.format !== ji) throw new Error("Unknown depthTexture format"); e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, a, 0) } }(r.__webglFramebuffer, t) } else if (a) { r.__webglDepthbuffer = []; for (let i = 0; i < 6; i++)n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = e.createRenderbuffer(), E(r.__webglDepthbuffer[i], t, !1) } else n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer), r.__webglDepthbuffer = e.createRenderbuffer(), E(r.__webglDepthbuffer, t, !1); n.bindFramebuffer(e.FRAMEBUFFER, null) } function M(e) { return T && e.isWebGLMultisampleRenderTarget ? Math.min(L, e.samples) : 0 } const T = r.isWebGL2, S = r.maxTextures, A = r.maxCubemapSize, R = r.maxTextureSize, L = r.maxSamples, C = new WeakMap; let P, N = !1; try { N = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d") } catch (e) { } let I = 0; const D = { [vi]: e.REPEAT, [yi]: e.CLAMP_TO_EDGE, [xi]: e.MIRRORED_REPEAT }, O = { [_i]: e.NEAREST, [bi]: e.NEAREST_MIPMAP_NEAREST, [Ei]: e.NEAREST_MIPMAP_LINEAR, [wi]: e.LINEAR, [Mi]: e.LINEAR_MIPMAP_NEAREST, [Ti]: e.LINEAR_MIPMAP_LINEAR }; let F = !1, B = !1; this.allocateTextureUnit = function () { const e = I; return e >= S && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + S), I += 1, e }, this.resetTextureUnits = function () { I = 0 }, this.setTexture2D = g, this.setTexture2DArray = function (t, r) { const a = i.get(t); t.version > 0 && a.__version !== t.version ? _(a, t, r) : (n.activeTexture(e.TEXTURE0 + r), n.bindTexture(e.TEXTURE_2D_ARRAY, a.__webglTexture)) }, this.setTexture3D = function (t, r) { const a = i.get(t); t.version > 0 && a.__version !== t.version ? _(a, t, r) : (n.activeTexture(e.TEXTURE0 + r), n.bindTexture(e.TEXTURE_3D, a.__webglTexture)) }, this.setTextureCube = v, this.setupRenderTarget = function (t) { const r = t.texture, s = i.get(t), c = i.get(r); t.addEventListener("dispose", m), c.__webglTexture = e.createTexture(), c.__version = r.version, o.memory.textures++; const p = !0 === t.isWebGLCubeRenderTarget, f = !0 === t.isWebGLMultisampleRenderTarget, g = r.isDataTexture3D || r.isDataTexture2DArray, v = l(t) || T; if (!T || r.format !== Ui || r.type !== Ni && r.type !== Ii || (r.format = ki, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), p) { s.__webglFramebuffer = []; for (let t = 0; t < 6; t++)s.__webglFramebuffer[t] = e.createFramebuffer() } else if (s.__webglFramebuffer = e.createFramebuffer(), f) if (T) { s.__webglMultisampledFramebuffer = e.createFramebuffer(), s.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, s.__webglColorRenderbuffer); const i = a.convert(r.format), o = a.convert(r.type), c = d(r.internalFormat, i, o), l = M(t); e.renderbufferStorageMultisample(e.RENDERBUFFER, l, c, t.width, t.height), n.bindFramebuffer(e.FRAMEBUFFER, s.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, s.__webglColorRenderbuffer), e.bindRenderbuffer(e.RENDERBUFFER, null), t.depthBuffer && (s.__webglDepthRenderbuffer = e.createRenderbuffer(), E(s.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(e.FRAMEBUFFER, null) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."); if (p) { n.bindTexture(e.TEXTURE_CUBE_MAP, c.__webglTexture), y(e.TEXTURE_CUBE_MAP, r, v); for (let n = 0; n < 6; n++)b(s.__webglFramebuffer[n], t, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n); h(r, v) && u(e.TEXTURE_CUBE_MAP, r, t.width, t.height), n.bindTexture(e.TEXTURE_CUBE_MAP, null) } else { let i = e.TEXTURE_2D; g && (T ? i = r.isDataTexture3D ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(i, c.__webglTexture), y(i, r, v), b(s.__webglFramebuffer, t, e.COLOR_ATTACHMENT0, i), h(r, v) && u(e.TEXTURE_2D, r, t.width, t.height), n.bindTexture(e.TEXTURE_2D, null) } t.depthBuffer && w(t) }, this.updateRenderTargetMipmap = function (t) { const r = t.texture; if (h(r, l(t) || T)) { const a = t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D, o = i.get(r).__webglTexture; n.bindTexture(a, o), u(a, r, t.width, t.height), n.bindTexture(a, null) } }, this.updateMultisampleRenderTarget = function (t) { if (t.isWebGLMultisampleRenderTarget) if (T) { const r = i.get(t); n.bindFramebuffer(e.READ_FRAMEBUFFER, r.__webglMultisampledFramebuffer), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, r.__webglFramebuffer); const a = t.width, o = t.height; let s = e.COLOR_BUFFER_BIT; t.depthBuffer && (s |= e.DEPTH_BUFFER_BIT), t.stencilBuffer && (s |= e.STENCIL_BUFFER_BIT), e.blitFramebuffer(0, 0, a, o, 0, 0, a, o, s, e.NEAREST), n.bindFramebuffer(e.FRAMEBUFFER, r.__webglMultisampledFramebuffer) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.") }, this.safeSetTexture2D = function (e, t) { e && e.isWebGLRenderTarget && (!1 === F && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), F = !0), e = e.texture), g(e, t) }, this.safeSetTextureCube = function (e, t) { e && e.isWebGLCubeRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), B = !0), e = e.texture), v(e, t) } } function Ye(e, t, n) { const i = n.isWebGL2; return { convert: function (n) { let r; if (n === Si) return e.UNSIGNED_BYTE; if (n === Di) return e.UNSIGNED_SHORT_4_4_4_4; if (n === Oi) return e.UNSIGNED_SHORT_5_5_5_1; if (n === Fi) return e.UNSIGNED_SHORT_5_6_5; if (n === Ai) return e.BYTE; if (n === Ri) return e.SHORT; if (n === Li) return e.UNSIGNED_SHORT; if (n === Ci) return e.INT; if (n === Pi) return e.UNSIGNED_INT; if (n === Ni) return e.FLOAT; if (n === Ii) return i ? e.HALF_FLOAT : null !== (r = t.get("OES_texture_half_float")) ? r.HALF_FLOAT_OES : null; if (n === Hi) return e.ALPHA; if (n === Ui) return e.RGB; if (n === ki) return e.RGBA; if (n === Gi) return e.LUMINANCE; if (n === zi) return e.LUMINANCE_ALPHA; if (n === Wi) return e.DEPTH_COMPONENT; if (n === ji) return e.DEPTH_STENCIL; if (n === Xi) return e.RED; if (n === qi) return e.RED_INTEGER; if (n === Yi) return e.RG; if (n === Ki) return e.RG_INTEGER; if (n === Zi) return e.RGB_INTEGER; if (n === Ji) return e.RGBA_INTEGER; if (n === Qi || n === $i || n === er || n === tr) { if (null === (r = t.get("WEBGL_compressed_texture_s3tc"))) return null; if (n === Qi) return r.COMPRESSED_RGB_S3TC_DXT1_EXT; if (n === $i) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (n === er) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (n === tr) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT } if (n === nr || n === ir || n === rr || n === ar) { if (null === (r = t.get("WEBGL_compressed_texture_pvrtc"))) return null; if (n === nr) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (n === ir) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (n === rr) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (n === ar) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (n === or) return null !== (r = t.get("WEBGL_compressed_texture_etc1")) ? r.COMPRESSED_RGB_ETC1_WEBGL : null; if ((n === sr || n === cr) && null !== (r = t.get("WEBGL_compressed_texture_etc"))) { if (n === sr) return r.COMPRESSED_RGB8_ETC2; if (n === cr) return r.COMPRESSED_RGBA8_ETC2_EAC } return n === lr || n === hr || n === ur || n === dr || n === pr || n === fr || n === mr || n === gr || n === vr || n === yr || n === xr || n === _r || n === br || n === Er || n === Mr || n === Tr || n === Sr || n === Ar || n === Rr || n === Lr || n === Cr || n === Pr || n === Nr || n === Ir || n === Dr || n === Or || n === Fr || n === Br ? null !== (r = t.get("WEBGL_compressed_texture_astc")) ? n : null : n === wr ? null !== (r = t.get("EXT_texture_compression_bptc")) ? n : null : n === Bi ? i ? e.UNSIGNED_INT_24_8 : null !== (r = t.get("WEBGL_depth_texture")) ? r.UNSIGNED_INT_24_8_WEBGL : null : void 0 } } } function Ke() { this._targetRay = null, this._grip = null, this._hand = null } function Ze(e, t) { function n(e) { const t = f.get(e.inputSource); t && t.dispatchEvent({ type: e.type, data: e.inputSource }) } function i() { f.forEach(function (e, t) { e.disconnect(t) }), f.clear(), x = null, _ = null, s.bindXRFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), M.stop(), o.isPresenting = !1, o.dispatchEvent({ type: "sessionend" }) } function r(e) { const t = c.inputSources; for (let e = 0; e < p.length; e++)f.set(t[e], p[e]); for (let t = 0; t < e.removed.length; t++) { const n = e.removed[t], i = f.get(n); i && (i.dispatchEvent({ type: "disconnected", data: n }), f.delete(n)) } for (let t = 0; t < e.added.length; t++) { const n = e.added[t], i = f.get(n); i && i.dispatchEvent({ type: "connected", data: n }) } } function a(e, t) { null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert() } const o = this, s = e.state; let c = null, l = 1, h = null, u = "local-floor", d = null; const p = [], f = new Map, m = new L; m.layers.enable(1), m.viewport = new la; const g = new L; g.layers.enable(2), g.viewport = new la; const v = [m, g], y = new js; y.layers.enable(1), y.layers.enable(2); let x = null, _ = null; this.enabled = !1, this.isPresenting = !1, this.getController = function (e) { let t = p[e]; return void 0 === t && (t = new Ke, p[e] = t), t.getTargetRaySpace() }, this.getControllerGrip = function (e) { let t = p[e]; return void 0 === t && (t = new Ke, p[e] = t), t.getGripSpace() }, this.getHand = function (e) { let t = p[e]; return void 0 === t && (t = new Ke, p[e] = t), t.getHandSpace() }, this.setFramebufferScaleFactor = function (e) { l = e, !0 === o.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (e) { u = e, !0 === o.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return h }, this.getSession = function () { return c }, this.setSession = async function (e) { if (null !== (c = e)) { c.addEventListener("select", n), c.addEventListener("selectstart", n), c.addEventListener("selectend", n), c.addEventListener("squeeze", n), c.addEventListener("squeezestart", n), c.addEventListener("squeezeend", n), c.addEventListener("end", i), c.addEventListener("inputsourceschange", r); const e = t.getContextAttributes(); !0 !== e.xrCompatible && await t.makeXRCompatible(); const a = { antialias: e.antialias, alpha: e.alpha, depth: e.depth, stencil: e.stencil, framebufferScaleFactor: l }, s = new XRWebGLLayer(c, t, a); c.updateRenderState({ baseLayer: s }), h = await c.requestReferenceSpace(u), M.setContext(c), M.start(), o.isPresenting = !0, o.dispatchEvent({ type: "sessionstart" }) } }; const b = new pa, E = new pa; this.getCamera = function (e) { y.near = g.near = m.near = e.near, y.far = g.far = m.far = e.far, x === y.near && _ === y.far || (c.updateRenderState({ depthNear: y.near, depthFar: y.far }), x = y.near, _ = y.far); const t = e.parent, n = y.cameras; a(y, t); for (let e = 0; e < n.length; e++)a(n[e], t); e.matrixWorld.copy(y.matrixWorld), e.matrix.copy(y.matrix), e.matrix.decompose(e.position, e.quaternion, e.scale); const i = e.children; for (let e = 0, t = i.length; e < t; e++)i[e].updateMatrixWorld(!0); return 2 === n.length ? function (e, t, n) { b.setFromMatrixPosition(t.matrixWorld), E.setFromMatrixPosition(n.matrixWorld); const i = b.distanceTo(E), r = t.projectionMatrix.elements, a = n.projectionMatrix.elements, o = r[14] / (r[10] - 1), s = r[14] / (r[10] + 1), c = (r[9] + 1) / r[5], l = (r[9] - 1) / r[5], h = (r[8] - 1) / r[0], u = (a[8] + 1) / a[0], d = o * h, p = o * u, f = i / (-h + u), m = f * -h; t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert(); const g = o + f, v = s + f, y = d - m, x = p + (i - m), _ = c * s / v * g, w = l * s / v * g; e.projectionMatrix.makePerspective(y, x, _, w, g, v) }(y, m, g) : y.projectionMatrix.copy(m.projectionMatrix), y }; let w = null; const M = new C; M.setAnimationLoop(function (e, t) { if (null !== (d = t.getViewerPose(h))) { const e = d.views, t = c.renderState.baseLayer; s.bindXRFramebuffer(t.framebuffer); let n = !1; e.length !== y.cameras.length && (y.cameras.length = 0, n = !0); for (let i = 0; i < e.length; i++) { const r = e[i], a = t.getViewport(r), o = v[i]; o.matrix.fromArray(r.transform.matrix), o.projectionMatrix.fromArray(r.projectionMatrix), o.viewport.set(a.x, a.y, a.width, a.height), 0 === i && y.matrix.copy(o.matrix), !0 === n && y.cameras.push(o) } } const n = c.inputSources; for (let e = 0; e < p.length; e++) { const i = p[e], r = n[e]; i.update(r, t, h) } w && w(e, t) }), this.setAnimationLoop = function (e) { w = e }, this.dispose = function () { } } function Je(e) { function t(t, n) { t.opacity.value = n.opacity, n.color && t.diffuse.value.copy(n.color), n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (t.map.value = n.map), n.alphaMap && (t.alphaMap.value = n.alphaMap), n.specularMap && (t.specularMap.value = n.specularMap); const i = e.get(n).envMap; if (i) { t.envMap.value = i, t.flipEnvMap.value = i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1, t.reflectivity.value = n.reflectivity, t.refractionRatio.value = n.refractionRatio; const r = e.get(i).__maxMipLevel; void 0 !== r && (t.maxMipLevel.value = r) } n.lightMap && (t.lightMap.value = n.lightMap, t.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (t.aoMap.value = n.aoMap, t.aoMapIntensity.value = n.aoMapIntensity); let r; n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix)); let a; n.aoMap ? a = n.aoMap : n.lightMap && (a = n.lightMap), void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture), !0 === a.matrixAutoUpdate && a.updateMatrix(), t.uv2Transform.value.copy(a.matrix)) } function n(t, n) { t.roughness.value = n.roughness, t.metalness.value = n.metalness, n.roughnessMap && (t.roughnessMap.value = n.roughnessMap), n.metalnessMap && (t.metalnessMap.value = n.metalnessMap), n.emissiveMap && (t.emissiveMap.value = n.emissiveMap), n.bumpMap && (t.bumpMap.value = n.bumpMap, t.bumpScale.value = n.bumpScale, n.side === Mn && (t.bumpScale.value *= -1)), n.normalMap && (t.normalMap.value = n.normalMap, t.normalScale.value.copy(n.normalScale), n.side === Mn && t.normalScale.value.negate()), n.displacementMap && (t.displacementMap.value = n.displacementMap, t.displacementScale.value = n.displacementScale, t.displacementBias.value = n.displacementBias); e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity) } return { refreshFogUniforms: function (e, t) { e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density) }, refreshMaterialUniforms: function (e, i, r, a) { i.isMeshBasicMaterial ? t(e, i) : i.isMeshLambertMaterial ? (t(e, i), function (e, t) { t.emissiveMap && (e.emissiveMap.value = t.emissiveMap) }(e, i)) : i.isMeshToonMaterial ? (t(e, i), function (e, t) { t.gradientMap && (e.gradientMap.value = t.gradientMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Mn && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Mn && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, i)) : i.isMeshPhongMaterial ? (t(e, i), function (e, t) { e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Mn && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Mn && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, i)) : i.isMeshStandardMaterial ? (t(e, i), i.isMeshPhysicalMaterial ? function (e, t) { n(e, t), e.reflectivity.value = t.reflectivity, e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.sheen && e.sheen.value.copy(t.sheen), t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap), t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), e.clearcoatNormalMap.value = t.clearcoatNormalMap, t.side === Mn && e.clearcoatNormalScale.value.negate()), e.transmission.value = t.transmission, t.transmissionMap && (e.transmissionMap.value = t.transmissionMap) }(e, i) : n(e, i)) : i.isMeshMatcapMaterial ? (t(e, i), function (e, t) { t.matcap && (e.matcap.value = t.matcap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Mn && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Mn && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, i)) : i.isMeshDepthMaterial ? (t(e, i), function (e, t) { t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, i)) : i.isMeshDistanceMaterial ? (t(e, i), function (e, t) { t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance }(e, i)) : i.isMeshNormalMaterial ? (t(e, i), function (e, t) { t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === Mn && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === Mn && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(e, i)) : i.isLineBasicMaterial ? (function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity }(e, i), i.isLineDashedMaterial && function (e, t) { e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale }(e, i)) : i.isPointsMaterial ? function (e, t, n, i) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * n, e.scale.value = .5 * i, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap); let r; t.map ? r = t.map : t.alphaMap && (r = t.alphaMap), void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)) }(e, i, r, a) : i.isSpriteMaterial ? function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap); let n; t.map ? n = t.map : t.alphaMap && (n = t.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), e.uvTransform.value.copy(n.matrix)) }(e, i) : i.isShadowMaterial ? (e.color.value.copy(i.color), e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1) } } } function Qe(e) { function t() { return null === W ? Q : 1 } function n(e, t) { for (let n = 0; n < e.length; n++) { const i = e[n], r = v.getContext(i, t); if (null !== r) return r } return null } function i() { ue = new function (e) { function t(t) { if (void 0 !== n[t]) return n[t]; let i; switch (t) { case "WEBGL_depth_texture": i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: i = e.getExtension(t) }return n[t] = i, i } const n = {}; return { has: function (e) { return null !== t(e) }, init: function (e) { e.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float") }, get: function (e) { const n = t(e); return null === n && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), n } } }(he), de = new function (e, t, n) { function i(t) { if ("highp" === t) { if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp"; t = "mediump" } return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp" } let r; const a = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext; let o = void 0 !== n.precision ? n.precision : "highp"; const s = i(o); s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s); const c = !0 === n.logarithmicDepthBuffer, l = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), h = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS), u = e.getParameter(e.MAX_TEXTURE_SIZE), d = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE), p = e.getParameter(e.MAX_VERTEX_ATTRIBS), f = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS), m = e.getParameter(e.MAX_VARYING_VECTORS), g = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS), v = h > 0, y = a || t.has("OES_texture_float"); return { isWebGL2: a, getMaxAnisotropy: function () { if (void 0 !== r) return r; if (!0 === t.has("EXT_texture_filter_anisotropic")) { const n = t.get("EXT_texture_filter_anisotropic"); r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else r = 0; return r }, getMaxPrecision: i, precision: o, logarithmicDepthBuffer: c, maxTextures: l, maxVertexTextures: h, maxTextureSize: u, maxCubemapSize: d, maxAttributes: p, maxVertexUniforms: f, maxVaryings: m, maxFragmentUniforms: g, vertexTextures: v, floatFragmentTextures: y, floatVertexTextures: v && y, maxSamples: a ? e.getParameter(e.MAX_SAMPLES) : 0 } }(he, ue, e), ue.init(de), Ne = new Ye(he, ue, de), pe = new function (e, t, n) { function i(t, n, i) { const r = new Uint8Array(4), a = e.createTexture(); e.bindTexture(t, a), e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST); for (let t = 0; t < i; t++)e.texImage2D(n + t, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, r); return a } function r(t) { !0 !== m[t] && (e.enable(t), m[t] = !0) } function a(t) { !1 !== m[t] && (e.disable(t), m[t] = !1) } function o(t, n, i, o, s, c, l, h) { if (t !== Sn) { if (!1 === x && (r(e.BLEND), x = !0), t === Pn) s = s || n, c = c || i, l = l || o, n === b && s === M || (e.blendEquationSeparate(z[n], z[s]), b = n, M = s), i === E && o === w && c === T && l === S || (e.blendFuncSeparate(V[i], V[o], V[c], V[l]), E = i, w = o, T = c, S = l), _ = t, A = null; else if (t !== _ || h !== A) { if (b === Nn && M === Nn || (e.blendEquation(e.FUNC_ADD), b = Nn, M = Nn), h) switch (t) { case An: e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA); break; case Rn: e.blendFunc(e.ONE, e.ONE); break; case Ln: e.blendFuncSeparate(e.ZERO, e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ONE_MINUS_SRC_ALPHA); break; case Cn: e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) } else switch (t) { case An: e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA); break; case Rn: e.blendFunc(e.SRC_ALPHA, e.ONE); break; case Ln: e.blendFunc(e.ZERO, e.ONE_MINUS_SRC_COLOR); break; case Cn: e.blendFunc(e.ZERO, e.SRC_COLOR); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) }E = null, w = null, T = null, S = null, _ = t, A = h } } else !0 === x && (a(e.BLEND), x = !1) } function s(t) { R !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), R = t) } function c(t) { t !== vn ? (r(e.CULL_FACE), t !== L && (t === yn ? e.cullFace(e.BACK) : t === xn ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : a(e.CULL_FACE), L = t } function l(t, n, i) { t ? (r(e.POLYGON_OFFSET_FILL), P === n && N === i || (e.polygonOffset(n, i), P = n, N = i)) : a(e.POLYGON_OFFSET_FILL) } function h(t) { void 0 === t && (t = e.TEXTURE0 + I - 1), B !== t && (e.activeTexture(t), B = t) } const u = n.isWebGL2, d = new function () { let t = !1; const n = new la; let i = null; const r = new la(0, 0, 0, 0); return { setMask: function (n) { i === n || t || (e.colorMask(n, n, n, n), i = n) }, setLocked: function (e) { t = e }, setClear: function (t, i, a, o, s) { !0 === s && (t *= o, i *= o, a *= o), n.set(t, i, a, o), !1 === r.equals(n) && (e.clearColor(t, i, a, o), r.copy(n)) }, reset: function () { t = !1, i = null, r.set(-1, 0, 0, 0) } } }, p = new function () { let t = !1, n = null, i = null, o = null; return { setTest: function (t) { t ? r(e.DEPTH_TEST) : a(e.DEPTH_TEST) }, setMask: function (i) { n === i || t || (e.depthMask(i), n = i) }, setFunc: function (t) { if (i !== t) { if (t) switch (t) { case Yn: e.depthFunc(e.NEVER); break; case Kn: e.depthFunc(e.ALWAYS); break; case Zn: e.depthFunc(e.LESS); break; case Jn: e.depthFunc(e.LEQUAL); break; case Qn: e.depthFunc(e.EQUAL); break; case $n: e.depthFunc(e.GEQUAL); break; case ei: e.depthFunc(e.GREATER); break; case ti: e.depthFunc(e.NOTEQUAL); break; default: e.depthFunc(e.LEQUAL) } else e.depthFunc(e.LEQUAL); i = t } }, setLocked: function (e) { t = e }, setClear: function (t) { o !== t && (e.clearDepth(t), o = t) }, reset: function () { t = !1, n = null, i = null, o = null } } }, f = new function () { let t = !1, n = null, i = null, o = null, s = null, c = null, l = null, h = null, u = null; return { setTest: function (n) { t || (n ? r(e.STENCIL_TEST) : a(e.STENCIL_TEST)) }, setMask: function (i) { n === i || t || (e.stencilMask(i), n = i) }, setFunc: function (t, n, r) { i === t && o === n && s === r || (e.stencilFunc(t, n, r), i = t, o = n, s = r) }, setOp: function (t, n, i) { c === t && l === n && h === i || (e.stencilOp(t, n, i), c = t, l = n, h = i) }, setLocked: function (e) { t = e }, setClear: function (t) { u !== t && (e.clearStencil(t), u = t) }, reset: function () { t = !1, n = null, i = null, o = null, s = null, c = null, l = null, h = null, u = null } } }; let m = {}, g = null, v = {}, y = null, x = !1, _ = null, b = null, E = null, w = null, M = null, T = null, S = null, A = !1, R = null, L = null, C = null, P = null, N = null; const I = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS); let D = !1, O = 0; const F = e.getParameter(e.VERSION); -1 !== F.indexOf("WebGL") ? (O = parseFloat(/^WebGL (\d)/.exec(F)[1]), D = O >= 1) : -1 !== F.indexOf("OpenGL ES") && (O = parseFloat(/^OpenGL ES (\d)/.exec(F)[1]), D = O >= 2); let B = null, H = {}; const U = new la(0, 0, e.canvas.width, e.canvas.height), k = new la(0, 0, e.canvas.width, e.canvas.height), G = {}; G[e.TEXTURE_2D] = i(e.TEXTURE_2D, e.TEXTURE_2D, 1), G[e.TEXTURE_CUBE_MAP] = i(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), d.setClear(0, 0, 0, 1), p.setClear(1), f.setClear(0), r(e.DEPTH_TEST), p.setFunc(Jn), s(!1), c(yn), r(e.CULL_FACE), o(Sn); const z = { [Nn]: e.FUNC_ADD, [In]: e.FUNC_SUBTRACT, [Dn]: e.FUNC_REVERSE_SUBTRACT }; if (u) z[On] = e.MIN, z[Fn] = e.MAX; else { const e = t.get("EXT_blend_minmax"); null !== e && (z[On] = e.MIN_EXT, z[Fn] = e.MAX_EXT) } const V = { [Bn]: e.ZERO, [Hn]: e.ONE, [Un]: e.SRC_COLOR, [Gn]: e.SRC_ALPHA, [qn]: e.SRC_ALPHA_SATURATE, [jn]: e.DST_COLOR, [Vn]: e.DST_ALPHA, [kn]: e.ONE_MINUS_SRC_COLOR, [zn]: e.ONE_MINUS_SRC_ALPHA, [Xn]: e.ONE_MINUS_DST_COLOR, [Wn]: e.ONE_MINUS_DST_ALPHA }; return { buffers: { color: d, depth: p, stencil: f }, enable: r, disable: a, bindFramebuffer: function (t, n) { null === n && null !== g && (n = g), v[t] !== n && (e.bindFramebuffer(t, n), v[t] = n) }, bindXRFramebuffer: function (t) { t !== g && (e.bindFramebuffer(e.FRAMEBUFFER, t), g = t) }, useProgram: function (t) { return y !== t && (e.useProgram(t), y = t, !0) }, setBlending: o, setMaterial